List of targets for each person.

A target is:
  time, x, y, rot.

Always animate w/ beat: either "keep time" (in place) or an
 appropriate amount of "press ahead", "sashay left", "sashay right",
   or "press back", depending on motion vector/facing direction.

              motion vec
facing dir | /
           |/__ <- sashay component.
           ^
           press ahead/back component.

Also need 'turn left' and 'turn right' movements.  All movements
should be two part (left foot, then right foot), but 1 beat = 1 step
(ie, half the cycle).  "Scoot back", for example, is 3 beats: 1 step
straight ahead, 1 turning step for trade, 1 step straight back.
So always interpolating between three keyframes, one for "x", one for
"y", and one for rotation.  (Writing animation for rotation will be
tricky: best start with spine rotating smoothly, then move all bones,
and then reset the rotation on the spine.)

Should use an independent timer to run camera homing, so that it not
dependent on song timing.  Current values are okay for 96<FPS<170.
** Rather than fixed rate pan/tilt, write an acceleration profile
which will return to 'home' in 1 beat.  Record distance from target
of 'last user override' (ie, change of view or manual pan/tilt).
Based on current distance, apply /\ acceleration (increase velocity
unless we're at midpoint, else decrease.)  Need some math to figure
out what the delta V should be, based on actual dist/total dist.

Should use frame-rate limited display: 15fps?  30fps?

Also, use relative vertex animation for: head turns, smiles, hand
movements.  These are cycles, but we subtract the frame vertices from
the start vertices to get a displacement, and then apply the
displacement over whatever else is going on.  Also 'dropping'
something, and sound effects (claps, etc).

If the dancers are left stopped without a command, they should
initiate a 1-2 beat (randomize start/end points?) head turn in the
caller's direction (limited by neck mobility) -- also eye turn?

Dancers should also look towards their partners if their partner is
'near enough'.


The checkers can have a walking animation, too, tilting up & down and
'walking' across the table.  Maybe include global translation/rotation
matrix in keyframining?
---------

More points for sequences near 'optimal length' (ie, not too long or
short).

Points for consistent flow (flow meter increases, reset to zero on bad
flow).

Points for continuous calling (same deal, or maybe a bonus for a
continuous resolved sequence.)

Dancers may 'drop' objects: points for getting the dancer who dropped
the item to the place where it (randomly) ends up within a certain
time period.

Difficulty level: tempo, dancer appearance (arky/identical),
'turkeys'.

Bonus for recovering after a turkey.

Maybe caller movement as well to receive bonuses.

Meters: instantaneous 'flow', 'sequence length', 'originality'.
Score is the integral of the instantaneous values.
Originality is scored via histogram: sort calls by frequency, and
display bar.  More points for 'flat' graph (no calls over- or
under-used), and per-call score is positive if call frequency is below
average or negative is call frequency is above average.
Should consider bigram and trigram distributions, so that we penalize
"modules".  Perhaps make suggestions for alternate calls, based on freqs?
(NO: score at measure or phase boundaries.  Meter is integral of "good and bad"
things; current meter values==score, applied at discrete points.  Also
"resolve" bonus.)

----
splice 'miditimers' together to allow switching tunes?
 each time measurement is a rational number; pass this rational number
 between timers atomically to ensure monoticity.  main timer is just a
 switch.

Support sampled sound (wav/mp3) via "beat maps" -- a list of
 (beat number, micro-second location) pairs which are smoothly
 interpolated to reconstruct beat number from the playback us
 location.
--
To switch songs: turn on the loop; when we receive the 'music end'
 signal switch to new song?

From FAQ: http://www.jsresources.org/faq_midi.html#note_event_notification
 Add Meta events at switch points (at measure or phrase boundaries).
 When we get one of these events, stop the sequencers and start the
 next. See http://www.jsresources.org/faq_midi.html#schedule_events
 for ideas on dealing with lead-in: to wit, chain two switches. Switch
 to a silent track with 3 of the 4 beats and then a META event, which
 will trigger the switch to the 1 beat pickup.
 See also http://www.ii.uib.no/~espenr/midistreaming/ w/ regard to
 swapping sequencers for gapless playback.
---------
photos of barn.
---------
resolve:
 search both backwards and forwards.
 initially discard rotation information ('at home' getout vs not)
  and search from both ends (from the start & from the goal)
  discard actual call info after each deepen; just preserve the set of
  formations reachable.  Then when showing results, we can re-do the
  partial search from begin formation to end formation to show
  options.  If we want an at-home getout, we can search w/in the
  results, not discarding rotation info this time.  This reduces the
  search space, since the forward-dancing stage doesn't have to
  separately consider states which are identical except for rotation.
  (Alternately, search state is tuple of 'dancer-independent'
  formation and a set of possible dancer orderings (since there are
  only 24 possible symmetric orderings).
 user UI should allow you to select 'at home getouts', 'promenade
 1/4', 'promenade 1/2', 'promenade 3/4', etc. for singers.

----
IN should be applied both bottom-up and top-down.  'Inherent' length
is propagated bottom up (where prim and part = 1, and IN resets to its
spec), and then outermost INs are applied top-down, with available
beats according proportionally to 'inherent' length.

call application should reduce to a tree of nothing but IN PRIM and
SELECT.  Otherwise keep tree as high as possible for concept application.

------
Multiple formation option (advanced rounds)
Keep a List<Formation> around.  If there are several possible calls in the
"top-N" recognition options list, flip a coin (based on their
respective probabilities) to chose which one each square does.
Probably need selectors like "back square" to make this more fun,
although maybe "those who can" is enough.  Squares ignore calls they
can't do (and glare at the caller) until they hear a 'forward and
back', at which point they make lines.
------
All call predicates take a 'DanceState' as well as the Formation or
whatever else they are operating on.  The DanceState contains info
like the current program (which should be an enumeration).
------
counter rotate (for example) is:
  from: MINI_WAVE
    condition: PROGRAM AT LEAST(a2) // is this right?
    call: _counter rotate
  from: COUPLE
    condition: PROGRAM AT LEAST(c1) // or whatever
    call: _counter rotate
When using counter rotate to define other calls, use _counter rotate
or counter rotate, depending on whether the use is program-sensitive
or not.
------
Use call grammar to do a typing interface as well: do the
selected-text-while-typing thing to display the possible lookahead.
Space accepts the current lookahead.
------
For animation of complicated sequences, treat dancers as connected to
their desired locations with a spring.  Sense collisions and stretch
the spring as necessary (ie, don't walk through people).  Should
probably treat dancers as circles so they don't get stuck on each
other.  Each path has a "shoulder direction" which says which way they
attempt to go around obstacles.
-----
Roll direction is 'rot' component of last PRIM. (Not counting
'standing still' PRIMS, which are 0,0,none, or sound effects, which
have timing 0).  Sweep direction is 'sashay' component of last PRIM.
-----
Eventually: sound effects.  Special type of prim with timing 0?
Same for actions? (sound effects are triggered at prim location,
while actions are centered at prim location).
----
fractionalization can only occur in a Seq of Parts, not between
prim calls, or in mixed lists.  the 'and' concept creates a
divisible part for each call.  IPART is an 'indivisible part'
(XXX: we don't currently check homogenity of a Seq)
----
to do:
create plain-text parser (into APPLY trees)
add formation changes during Seqs to elaborate.
build dancerpath from simplified tree (PRIM/WARP/SELECT with numbered dancers)
animate dancer paths
  generalize rotation
----

Primitives coordinates can have 'in' and 'out' modifiers, which
multiply by +1 or -1 depending on vector to current formation center.
This way we don't need separate rules for (say) circulate from RH and
LH boxes; they both move "in 2" in the sashay direction. (Directions
are 'sashay, ahead', aka x,y.

---------

Formation warps are independent stretches of x,y axes.

First: taking a canonical formation and stretching to accomodate solid
dancers:
  First we write down the x (y) axis coordinates of "inner" boundary
  edges.  The x (y) boundary edges around a dancer at x,y are at x+1,
  x-1 (y+1, y-1). We only use the boundary edge which is closest to
  the origin; we assume we can safely expand to fill space in the
  other direction (ie, the centers in a diamond can expand to fit
  tandems in the typical tandem diamond formation).

  Then, for each formation, we identify the x (y) coordinates which
  bound the formation.  These are the points in the "inner boundary"
  list which are <= and >= our boundary edges in this
  axis.  (Note that, because only the inner boundary coordinates are in the
  list, there may not be an exact match for our edge.)  We ensure that
  the bounds are large enough to accomodate the desired x (y) size of
  this dancer by adjusting the 'output' list for these bounds; any
  points lying between the bounds are stretched proportionally.
  We work outward from the origin in both the positive and negative
  direction, so no recentering will be needed.

For example, if the X 'inner boundary' list was: -2,0,2 and we had a
three dancer formation with bounds -1,1 which needed to be at least 6
units wide, then we might stretch the output list from -2,0,2 to
-3,0,3.  Note that we've adjusted the mappings for -2 and 2, even
though our bounds are -1 and 1.  Note also that, since the original
formation straddled the origin, that we had to stretch in both
directions.  Usually only one 'inner boundary' edge is pushed out.

When actually placing the new dancers in the square, we don't
individually warp their points: we just identify the inner bounds in the
list (-2,2) as before, map these (-3,3) and drop our formation
undistorted hanging off its inner boundary.

Second: taking a given formation and shrinking it given blocks of
solid dancers (similar to the above):

  First we write down the x (y) axis coordinates of inner boundary
  edges.  The x (y) boundary edges around a dancer at x,y are at
  x+(w/2), x-(w/2) (y+(h/2), y-(h/2)), where w (h) is the width
  (height) of the solid dancer.  The 'inner' edges are the ones closest
  to the origin (one in X, one in Y).

  We then renumber these shared edges so that there are exactly 2
  units between each pair of points.  We linearly interpolate using
  this correspondence to warp the center point of the solid dancer to
  create a new canonical dancer; the mapping ensures that dancers
  created this way will not overlap (well, there may be some edge cases).

Note that compressing a tandem diamond in this fashion will result in
a 'short' diamond (points at (0,+/-2) instead of (0,+/-3).  We
recognize this as an alternative diamond formation that can be
breathed out into the standard diamond.
-----------
Dancers are diamond shaped:
  ^
 <+>
  v
with a 2-unit diameter.  This explains how stars can exist, but
aligned dancers can not be closer than 2 units apart.

-----------
FormationMatch should include both the formations matched, as well as
a 'meta formation' showing the arrangement of these.  Then, we apply
the calls in the subformations, and put the results together according
to the meta formation.

Each formation should also have a max size associated with it?  This
way we can give it extra space in the middle?  Think about 'lock it
twice' from parallel ocean waves.  Need to make sure we stretch in the
middle to accomodate the tidal wave.

(Maybe the reassembly should happen at each intermediate point?)

We generate a warp function which disassembles & then reassembles the
formations.
----------
elaborate should weed out inapplicable formations/evaluate conds, but
not do any irreversible rewriting.

The formation reconstruction which 'from' does is not currently
encapsulatable in a 'Warp' node.
---------

Handle collisions at the same time we do formation reconstruction: if
two dancers are on the same spot, replace them with a RH MINIWAVE
at that location.
---------

anything: LEFT leftable_anything // tight
	| REVERSE reversable_anything // tight
	| MIRROR anything // low
	| leftable_anything
	| reversable_anything
	| anything AND anything
	| anything AND ROLL
	;
	
leftable_anything
	: SQUARE THRU number
	;

//TANDEM (anything AND ROLL)

anything0: MIRROR anything1
	| anything1
	;
anything1: anything1 AND anything2
	| anything2
	;
anything2: anything2 AND ROLL
	| anything3
anything3: LEFT leftable_anything
	| REVERSE reversable_anything
	| anything4
	;
anything4
	: leftable_anything
	| reversable_anything
	| DOSADO
	| LPAREN anything0 RPAREN
	;
----------
how to deal with "swing and mix"/"and(swing,mix)" ambiguity?
Answer: post-process parse tree to create "(apply swing-and-mix)" from
"(apply and (apply swing) (apply mix))".

More tricky parses:
 <designator> (<anything> and <anything>)
 (<designator> <anything>) (and|while the) (<designator> <anything>)
 "swing and (TANDEM mix)" vs. "TANDEM (swing and mix)"
                          NOT "(TANDEM swing) and mix"
Use greedy parse?
or:
 <anything1> = <designator> <anything2>
             | <designator> <anything2> AND <designator> <anything2>
 <anything2> = <anything2> AND <anything2> // ie, no designators allowed here
 <anything3> = LPAREN <anything1> RPAREN

-----------
What about doing a "find all parses" with a truly ambiguous grammar?
We could do the same thing we do with speech recognition: try each
possible parse & discard any that don't work.
-----------

Whenever we try to match a formation and fail, try also to
match "isomorphic" formations & insert a 'breathe' operation if
necessary.  Make 'small diamonds' (points at (0,+/-2) isomorphic to 
'big diamonds' (points at (0,+/-3), just
like 'quarter tag with ends facing right' is isomorphic to 'twin
diamonds'. (and in some cases, facing couples are isomorphic to waves
& vice versa).
--------
Formation elaboration does:
 * simplifies formations known to be impossible, given input.
 * evaluates conditions.
 * inserts explicit 'breathing' nodes into the AST when:
    diamond/quarter tag conversion needs to occur
    short diamond/big diamond
    facing waves/step to a wave (concept '_no touch' means delete the
     initial '1/2 pass thru' so that pass thru from a wave becomes:
       from: MINIWAVE
       call: _no touch(pass thru)
     swing thru from facing couples becomes:
       from: FACING COUPLES
       call: touch, swing thru
    multiple formations exist -- ie, call is from 'diamonds' and we
    have 'twin diamonds'.  This allows us to decouple the 'formation
    reassembly' from elaboration.

Formation evaluation results in a series of time-stamped formations.
Tricky: how to combine parallel movements.  Do we interpolate (along
a curved path if necessary), refuse to interpolate (or only
interpolate linear actions), or something else? (some formations
missing some dancers?  some formations have 'old' positions for
dancers, used only for formation reassembly, not ultimately for dancer
movement interpolation?)  Use octagon interpolation of curved
movements?

The following pythagorean triples form a 10-degree approximation to
a circle (see pythagoras.html, which has a 5-degree approximation as well):
 105, 608, 617
  51, 140, 149
 120, 209, 241
  88, 105, 137
 (and their transposes, switching a for b)
We could do linear interpolation between these points to interpolate
paths and facing directions using rational arithmetic -- or we could
just do the exact floating point computation, and use the Fraction
method which generates a rational from a double -- but will this result
in overflow?  The benefit of the rational approximation is that we
know that the denominators are < 1000, which gives us plenty of room.
---------------
Use the Sphinx RuleGrammar to parse our inputs, rather than having a
separate ANTLRv3 grammar?  cons: Sphinx doesn't recognize ambiguity
in the grammar.  pro: it (seems to have) no problem with left recursion.
---------------
1. Each movement ought to be interpolated according to the momentary center of
the (sub)formation - ie, box counter rotate is an arcing movement, not a a
straightforward prim 0,2,right (for trailer in right hand box).  This is
important for roll/sweep and flow.
2. Post processing at SELECT (ParCall) should insert handhold actions for
connected dancers.  Actions are "left hand hold" and "right hand hold".
3. Evaluate returns list of "Prim or Action" per Dancer; these are applied
during SELECT (ParCall) processing to yield a formation.  (Separate class
does the combination from the sorted list of time steps).  Note that we may
need to interpolate paths in order to get a uniform set of steps; ensure
that crossing paths will actually result in identical locations for the
relevant dancers -- tricky for t-boned jaywalk.
4. Create 'or' selector: BOX = or(RH_BOX, LH_BOX)
   OCEAN_WAVE = or(RH_OCEAN_WAVE, LH_OCEAN_WAVE)
   Be careful to distinguish between 'general formations' and disjunctive
   selectors.  Use general formation where possible, and use GENERAL in the
   name of the selector.  BOX and OCEAN_WAVE can't be general selectors.
5. NEAR WAVE / NEAR LINE / FAR WAVE / FAR LINE tags?
-----
Result of evaluation includes:
 DancerPath:
   Point from, to, arcCenter; // arcCenter can be null for straight paths.
   Fraction time;
   ExactRotation from, to;
   PathType pt; // 1,2,4,8 person, for flow
   Rotation rollDir, sweepDir; // these can be none.
Some of these can be automatically computed from the other information.
----
Circular interpolation algorithm:
 0. If motion is explicitly tagged ("ARC") then use formation origin as
    arc center.  Otherwise:
 1. Get intersection of lines perp. to motion at start and end.
    If no intersection, then bail to straight line path.
 2. Check whether intersection is to left or right of motion direction,
    at both start and end.
    If intersection point is colinear with motion direction, bail to straight
    line path.
 3. If both left or both right, then arc is possible: center is at intersection
    point.  Otherwise, bail to straight line path.
-----
After SELECT fails, we go to a 'try harder' phase, where we try to find the
appropriate tags, irrespective of the current TaggedFormation.

After FROM fails, we 'try harder', which involves trying breathing and applying
"from facing couples" and "from waves" rules.  Need explicit tag in call
definition to say when this is/is not applicable?  Ie, recycle from facing
couples not okay using "from facing couples" rule.
----
Add audio feedback element to Sphinx frontend pipeline, between
edu.cmu.sphinx.frontend.util.Microphone and 
edu.cmu.sphinx.frontend.endpoint.SpeechClassifier.   Look at the
SpeechClassifer for ideas: it is estimating input level as well; we just need
a shorter time constant.  Alternatively, grab audio after the
edu.cmu.sphinx.frontend.endpoint.SpeechMarker; then we can use different
colors for non-speech (grey with high alpha) and speech (primary
color) data.
----
HUD To-Do:
 gauges (min/max and specify gradient texture?)
 support for scrolling "measure end" and "call stars"
 real time microphone volume display
----
Use ChaseCamera to 'chase' the center of the set.

Put HUD behind loading screen somehow.
----
Bonus formations on right.
Suggestions for 'new' calls you can do presently also on right.  Part
of 'tutorial'.  Can select "help" level.   Always give suggestion when
stalled.

Better error messages for calls. "Boys and Girls must be together" or
"only from waves or facing couples" eg when caller gets it wrong.

try to teach caller w/o having to rely on outside references?
----
Should add package.html files.
----
ScoreAccumulator should get updates when the dancers are waiting for
their next call, as the "timing and flow" meter should continue to run
down while they wait.  ScoreAccumulator 'goodCall' method should just
be responsible for the jump in "timing and flow" when a good call is
given.
---
Sphinx states like GameStates; pass Results around from each (since we
need different result processing in different states).

"Say "square up" or press enter to start" w/ high "out of grammar
utterance" probability.

Menu: microphone selection and volume (virtualize Sphinx "Microphone"
component?), # of dancers (4/8/12 <- "at home" really is at home for
everyone), dance program (basic->c4), judging (easy/medium/hard).

"Poor man's SD" (PMSD) interface, with text i/o to call engine.
--
Change background color so that loading screen looks better.
--
Display.setIcon() to use SDR application icon.
