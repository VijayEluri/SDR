List of targets for each person.

A target is:
  time, x, y, rot.

Always animate w/ beat: either "keep time" (in place) or an
 appropriate amount of "press ahead", "sashay left", "sashay right",
   or "press back", depending on motion vector/facing direction.

              motion vec
facing dir | /
           |/__ <- sashay component.
           ^
           press ahead/back component.

Also need 'turn left' and 'turn right' movements.  All movements
should be two part (left foot, then right foot), but 1 beat = 1 step
(ie, half the cycle).  "Scoot back", for example, is 3 beats: 1 step
straight ahead, 1 turning step for trade, 1 step straight back.
So always interpolating between three keyframes, one for "x", one for
"y", and one for rotation.  (Writing animation for rotation will be
tricky: best start with spine rotating smoothly, then move all bones,
and then reset the rotation on the spine.)

Should use an independent timer to run camera homing, so that it not
dependent on song timing.  Current values are okay for 96<FPS<170.
** Rather than fixed rate pan/tilt, write an acceleration profile
which will return to 'home' in 1 beat.  Record distance from target
of 'last user override' (ie, change of view or manual pan/tilt).
Based on current distance, apply /\ acceleration (increase velocity
unless we're at midpoint, else decrease.)  Need some math to figure
out what the delta V should be, based on actual dist/total dist.

Should use frame-rate limited display: 15fps?  30fps?

Also, use relative vertex animation for: head turns, smiles, hand
movements.  These are cycles, but we subtract the frame vertices from
the start vertices to get a displacement, and then apply the
displacement over whatever else is going on.  Also 'dropping'
something, and sound effects (claps, etc).

If the dancers are left stopped without a command, they should
initiate a 1-2 beat (randomize start/end points?) head turn in the
caller's direction (limited by neck mobility) -- also eye turn?

Dancers should also look towards their partners if their partner is
'near enough'.


The checkers can have a walking animation, too, tilting up & down and
'walking' across the table.  Maybe include global translation/rotation
matrix in keyframining?
---------

More points for sequences near 'optimal length' (ie, not too long or
short).

Points for consistent flow (flow meter increases, reset to zero on bad
flow).

Points for continuous calling (same deal, or maybe a bonus for a
continuous resolved sequence.)

Dancers may 'drop' objects: points for getting the dancer who dropped
the item to the place where it (randomly) ends up within a certain
time period.

Difficulty level: tempo, dancer appearance (arky/identical),
'turkeys'.

Bonus for recovering after a turkey.

Maybe caller movement as well to receive bonuses.

Meters: instantaneous 'flow', 'sequence length', 'originality'.
Score is the integral of the instantaneous values.
Originality is scored via histogram: sort calls by frequency, and
display bar.  More points for 'flat' graph (no calls over- or
under-used), and per-call score is positive if call frequency is below
average or negative is call frequency is above average.


----
splice 'miditimers' together to allow switching tunes?
 each time measurement is a rational number; pass this rational number
 between timers atomically to ensure monoticity.  main timer is just a
 switch.

Support sampled sound (wav/mp3) via "beat maps" -- a list of
 (beat number, micro-second location) pairs which are smoothly
 interpolated to reconstruct beat number from the playback us
 location.
--
To switch songs: turn on the loop; when we receive the 'music end'
 signal switch to new song?

From FAQ: http://www.jsresources.org/faq_midi.html#note_event_notification
 Add Meta events at switch points (at measure or phrase boundaries).
 When we get one of these events, stop the sequencers and start the
 next. See http://www.jsresources.org/faq_midi.html#schedule_events
 for ideas on dealing with lead-in: to wit, chain two switches. Switch
 to a silent track with 3 of the 4 beats and then a META event, which
 will trigger the switch to the 1 beat pickup.
 See also http://www.ii.uib.no/~espenr/midistreaming/ w/ regard to
 swapping sequencers for gapless playback.
---------
photos of barn.
---------
resolve:
 search both backwards and forwards.
 initially discard rotation information ('at home' getout vs not)
  and search from both ends (from the start & from the goal)
  discard actual call info after each deepen; just preserve the set of
  formations reachable.  Then when showing results, we can re-do the
  partial search from begin formation to end formation to show
  options.  If we want an at-home getout, we can search w/in the
  results, not discarding rotation info this time.  This reduces the
  search space, since the forward-dancing stage doesn't have to
  separately consider states which are identical except for rotation.
  (Alternately, search state is tuple of 'dancer-independent'
  formation and a set of possible dancer orderings (since there are
  only 24 possible symmetric orderings).
 user UI should allow you to select 'at home getouts', 'promenade
 1/4', 'promenade 1/2', 'promenade 3/4', etc. for singers.

----
IN should be applied both bottom-up and top-down.  'Inherent' length
is propagated bottom up (where prim and part = 1, and IN resets to its
spec), and then outermost INs are applied top-down, with available
beats according proportionally to 'inherent' length.

call application should reduce to a tree of nothing but IN PRIM and
SELECT.  Otherwise keep tree as high as possible for concept application.

------
Multiple formation option (advanced rounds)
Keep a List<Formation> around.  If there are several possible calls in the
"top-N" recognition options list, flip a coin (based on their
respective probabilities) to chose which one each square does.
Probably need selectors like "back square" to make this more fun,
although maybe "those who can" is enough.  Squares ignore calls they
can't do (and glare at the caller) until they hear a 'forward and
back', at which point they make lines.
------
All call predicates take a 'DanceState' as well as the Formation or
whatever else they are operating on.  The DanceState contains info
like the current program (which should be an enumeration).
------
counter rotate (for example) is:
  from: MINI_WAVE
    condition: PROGRAM AT LEAST(a2) // is this right?
    call: _counter rotate
  from: COUPLE
    condition: PROGRAM AT LEAST(c1) // or whatever
    call: _counter rotate
When using counter rotate to define other calls, use _counter rotate
or counter rotate, depending on whether the use is program-sensitive
or not.
------
Use call grammar to do a typing interface as well: do the
selected-text-while-typing thing to display the possible lookahead.
Space accepts the current lookahead.
------
For animation of complicated sequences, treat dancers as connected to
their desired locations with a spring.  Sense collisions and stretch
the spring as necessary (ie, don't walk through people).  Should
probably treat dancers as circles so they don't get stuck on each
other.  Each path has a "shoulder direction" which says which way they
attempt to go around obstacles.
-----
Roll direction is 'rot' component of last PRIM. (Not counting
'standing still' PRIMS, which are 0,0,none, or sound effects, which
have timing 0).
-----
Breathing is hard: create a bounding box around formation, and attach
springs to smush it toward the center?  Then a timing-sensitive warp
to apply the breathing.
----
Eventually: sound effects.  Special type of prim with timing 0?
Same for actions? (sound effects are triggered at prim location,
while actions are centered at prim location).
----
fractionalization can only occur in a Seq of Parts, not between
prim calls, or in mixed lists.  the 'and' concept creates a
divisible part for each call.  IPART is an 'indivisible part'
----
add 'mod' to Rotation to yield general direction. rotations are
consistent if: they're exactly equal.  Effective modulus is always
1/N for some N -- reduce fraction to lowest terms, then use denom.
for example, a modulus of 2/3 is equivalent to 1/3, since the
sequence goes 2/3, 4/3 == 1/3 mod 1, 6/3 == 0 mod 1.
For rotations with differing modulus, check that d1 % d2 = 0,
where d1 is the larger denom and d2 is the smaller.
----
to do:
create plain-text parser (into APPLY trees)
define 'elaborate'
build dancerpath from simplified tree (PRIM/WARP/SELECT with numbered dancers)
animate dancer paths
  define fractiona
  split IPATH from PATH (indivisible path)
  generalize rotation
----
expand call list to allow simple arguments -- probably not recursion
or conditionals, but certainly parameter substitution.  Tricky:
typing.  Make node in parse tree for 'expr', then CallBuilder will
be responsible for building the function.  Use helper AST class:
'ASTExpr' with subclasses for AST and Expr.  Attaching an AST to an
AST yields another AST; attaching an Expr to an Expr or an AST yields
and Expr. -- refactor 'build' method.
---------
No?  Just new Ast node for 'Ref', a leaf with a string value (the ref
identifier).

makeParameterizedCall(String name, Program level, Ast tree, String argNames...) 

Will do a tree walk, replacing Refs with the appropriate subtree
(correspondence given by argNames in the def and the string in the Ref node).
---------

Primitives coordinates can tell 'in' and 'out' modifiers, which
multiply by +1 or -1 depending on vector to current formation center.
This way we don't need separate rules for (say) circulate from RH and
LH boxes; they both move "+2in" in the sashay direction. (Directions
are 'sashay, ahead', aka x,y.

---------

Formation warps are independent stretches of x,y axes.

First: taking a canonical formation and stretching to accomodate solid
dancers:
  First we write down the x (y) axis coordinates of *shared* boundary
  edges.  The x (y) boundary edges around a dancer at x,y are at x+1,
  x-1 (y+1, y-1). We throw out any boundary edges which are not shared
  by at least two dancers: expansion of the formation is not
  constrained by these.

  Then, for each formation, we identify the x (y) coordinates which
  bound the formation.  These are the points in the "shared
  coordinate" list which are <= and >= our boundary edges in this
  axis.  (Note that, because only the shared coordinates are in the
  list, there may not be an exact match for our edge.)  We ensure that
  the edges are large enough to accomodate the desired x (y) size of
  this dancer by adjusting the 'output' list for these bounds; any
  points lying between the bounds are stretched proportionally.
  If needed, we then recenter the output list.

For example, if the X 'shared coordinate' list was: -2,0,2
and we had a three dancer formation with bounds -1,1 which needed to be
at least 6 units wide, then we might stretch the output list from
-2,0,2 to -2,1,4 before recentering at -3,0,3.  Note that we've
adjusted the mappings for -2 and 2, even though our bounds are -1 and
1.

When actually placing the new dancers in the square, we don't
individually warp their points: we just identify the bounds in the
shared list (-2,2) as before, map these (-3,3) and drop our formation
undistorted between these boundaries.

Note that, if one boundary is above/below the limits of the shared
edge list, we just assume it's big enough (don't need to adjust output
mapping) and drop the formation into place based on the position of
the known boundary and the natural size of the formation.  If both
boundaries are unknown, then assume no warp?  (This won't work for
properly restoring offset formations -- parallelogram/offset are a
separate mechanism.)

Second: taking a given formation and shrinking it given blocks of
solid dancers (similar to the above):

  First we write down the x (y) axis coordinates of *shared* boundary
  edges.  The x (y) boundary edges around a dancer at x,y are at
  x+(w/2), x-(w/2) (y+(h/2), y-(h/2)), where w (h) is the width
  (height) of the solid dancer. We throw out any boundary edges which
  are not shared by at least two dancers: contraction of the formation
  is not constrained by these.

  We then renumber these shared edges so that there are exactly 2
  units between each pair of points.  We linearly interpolate using
  this correspondence to warp the center point of the solid dancer to
  create a new canonical dancer; the mapping ensures that dancers
  created this way will not overlap (well, there may be some edge cases).
-----------
FormationMatch should include both the formations matched, as well as
a 'meta formation' showing the arrangement of these.  Then, we apply
the calls in the subformations, and put the results together according
to the meta formation.

Each formation should also have a max size associated with it?  This
way we can give it extra space in the middle?  Think about 'lock it
twice' from parallel ocean waves.  Need to make sure we stretch in the
middle to accomodate the tidal wave.

(Maybe the reassembly should happen at each intermediate point?)

We generate a warp function which disassembles & then reassembles the formations.
----------
elaborate should week out inapplicable formations, but not do any
irreversible rewriting.

The formation reconstruction which 'from' does is not currently
encapsulatable in a 'Warp' node.
---------

Handle collisions at the same time we do formation reconstruction: if
two dancers are on the same spot, replace them with a RH MINIWAVE
at that location.
---------
