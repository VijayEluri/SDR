List of targets for each person.

A target is:
  time, x, y, rot.

Always animate w/ beat: either "keep time" (in place) or an
 appropriate amount of "press ahead", "sashay left", "sashay right",
   or "press back", depending on motion vector/facing direction.

              motion vec
facing dir | /
           |/__ <- sashay component.
           ^
           press ahead/back component.

Also need 'turn left' and 'turn right' movements.  All movements
should be two part (left foot, then right foot), but 1 beat = 1 step
(ie, half the cycle).  "Scoot back", for example, is 3 beats: 1 step
straight ahead, 1 turning step for trade, 1 step straight back.
So always interpolating between three keyframes, one for "x", one for
"y", and one for rotation.  (Writing animation for rotation will be
tricky: best start with spine rotating smoothly, then move all bones,
and then reset the rotation on the spine.)

Should use an independent timer to run camera homing, so that it not
dependent on song timing.  Current values are okay for 96<FPS<170.
** Rather than fixed rate pan/tilt, write an acceleration profile
which will return to 'home' in 1 beat.  Record distance from target
of 'last user override' (ie, change of view or manual pan/tilt).
Based on current distance, apply /\ acceleration (increase velocity
unless we're at midpoint, else decrease.)  Need some math to figure
out what the delta V should be, based on actual dist/total dist.

Should use frame-rate limited display: 15fps?  30fps?

Also, use relative vertex animation for: head turns, smiles, hand
movements.  These are cycles, but we subtract the frame vertices from
the start vertices to get a displacement, and then apply the
displacement over whatever else is going on.  Also 'dropping'
something, and sound effects (claps, etc).

If the dancers are left stopped without a command, they should
initiate a 1-2 beat (randomize start/end points?) head turn in the
caller's direction (limited by neck mobility) -- also eye turn?

Dancers should also look towards their partners if their partner is
'near enough'.


The checkers can have a walking animation, too, tilting up & down and
'walking' across the table.  Maybe include global translation/rotation
matrix in keyframining?
---------

More points for sequences near 'optimal length' (ie, not too long or
short).

Points for consistent flow (flow meter increases, reset to zero on bad
flow).

Points for continuous calling (same deal, or maybe a bonus for a
continuous resolved sequence.)

Dancers may 'drop' objects: points for getting the dancer who dropped
the item to the place where it (randomly) ends up within a certain
time period.

Difficulty level: tempo, dancer appearance (arky/identical),
'turkeys'.

Bonus for recovering after a turkey.

Maybe caller movement as well to receive bonuses.

Meters: instantaneous 'flow', 'sequence length', 'originality'.
Score is the integral of the instantaneous values.
Originality is scored via histogram: sort calls by frequency, and
display bar.  More points for 'flat' graph (no calls over- or
under-used), and per-call score is positive if call frequency is below
average or negative is call frequency is above average.


----
splice 'miditimers' together to allow switching tunes?
 each time measurement is a rational number; pass this rational number
 between timers atomically to ensure monoticity.  main timer is just a
 switch.

Support sampled sound (wav/mp3) via "beat maps" -- a list of
 (beat number, micro-second location) pairs which are smoothly
 interpolated to reconstruct beat number from the playback us
 location.
--
To switch songs: turn on the loop; when we receive the 'music end'
 signal switch to new song?

From FAQ: http://www.jsresources.org/faq_midi.html#note_event_notification
 Add Meta events at switch points (at measure or phrase boundaries).
 When we get one of these events, stop the sequencers and start the
 next. See http://www.jsresources.org/faq_midi.html#schedule_events
 for ideas on dealing with lead-in: to wit, chain two switches. Switch
 to a silent track with 3 of the 4 beats and then a META event, which
 will trigger the switch to the 1 beat pickup.
 See also http://www.ii.uib.no/~espenr/midistreaming/ w/ regard to
 swapping sequencers for gapless playback.
---------
photos of barn.
---------
resolve:
 search both backwards and forwards.
 initially discard rotation information ('at home' getout vs not)
  and search from both ends (from the start & from the goal)
  discard actual call info after each deepen; just preserve the set of
  formations reachable.  Then when showing results, we can re-do the
  partial search from begin formation to end formation to show
  options.  If we want an at-home getout, we can search w/in the
  results, not discarding rotation info this time.  This reduces the
  search space, since the forward-dancing stage doesn't have to
  separately consider states which are identical except for rotation.
  (Alternately, search state is tuple of 'dancer-independent'
  formation and a set of possible dancer orderings (since there are
  only 24 possible symmetric orderings).
 user UI should allow you to select 'at home getouts', 'promenade
 1/4', 'promenade 1/2', 'promenade 3/4', etc. for singers.

----
IN should be applied both bottom-up and top-down.  'Inherent' length
is propagated bottom up (where prim and part = 1, and IN resets to its
spec), and then outermost INs are applied top-down, with available
beats according proportionally to 'inherent' length.

call application should reduce to a tree of nothing but IN PRIM and
SELECT.  Otherwise keep tree as high as possible for concept application.

------
Multiple formation option (advanced rounds)
Keep a List<Formation> around.  If there are several possible calls in the
"top-N" recognition options list, flip a coin (based on their
respective probabilities) to chose which one each square does.
Probably need selectors like "back square" to make this more fun,
although maybe "those who can" is enough.  Squares ignore calls they
can't do (and glare at the caller) until they hear a 'forward and
back', at which point they make lines.
------
All call predicates take a 'DanceState' as well as the Formation or
whatever else they are operating on.  The DanceState contains info
like the current program (which should be an enumeration).
------
counter rotate (for example) is:
  from: MINI_WAVE
    condition: PROGRAM AT LEAST(a2) // is this right?
    call: _counter rotate
  from: COUPLE
    condition: PROGRAM AT LEAST(c1) // or whatever
    call: _counter rotate
When using counter rotate to define other calls, use _counter rotate
or counter rotate, depending on whether the use is program-sensitive
or not.
------
Use call grammar to do a typing interface as well: do the
selected-text-while-typing thing to display the possible lookahead.
Space accepts the current lookahead.
------
For animation of complicated sequences, treat dancers as connected to
their desired locations with a spring.  Sense collisions and stretch
the spring as necessary (ie, don't walk through people).  Should
probably treat dancers as circles so they don't get stuck on each
other.  Each path has a "shoulder direction" which says which way they
attempt to go around obstacles.
-----
Roll direction is 'rot' component of last PRIM. (Not counting
'standing still' PRIMS, which are 0,0,none, or sound effects, which
have timing 0).
-----
Breathing is hard: create a bounding box around formation, and attach
springs to smush it toward the center?  Then a timing-sensitive warp
to apply the breathing.
----
Eventually: sound effects.  Special type of prim with timing 0?
Same for actions? (sound effects are triggered at prim location,
while actions are centered at prim location).
----
fractionalization can only occur in a Seq of Parts, not between
prim calls, or in mixed lists.  the 'and' concept creates a
divisible part for each call.  IPART is an 'indivisible part'
----
add 'mod' to Rotation to yield general direction. rotations are
consistent if: they're exactly equal.  Effective modulus is always
1/N for some N -- reduce fraction to lowest terms, then use denom.
for example, a modulus of 2/3 is equivalent to 1/3, since the
sequence goes 2/3, 4/3 == 1/3 mod 1, 6/3 == 0 mod 1.
For rotations with differing modulus, check that d1 % d2 = 0,
where d1 is the larger denom and d2 is the smaller.
----
to do:
create plain-text parser (into APPLY trees)
define 'elaborate'
build dancerpath from simplified tree (PRIM/WARP/SELECT with numbered dancers)
animate dancer paths
  define fractiona
  split IPATH from PATH (indivisible path)
  generalize rotation
----
expand call list to allow simple arguments -- probably not recursion
or conditionals, but certainly parameter substitution.  Tricky:
typing.  Make node in parse tree for 'expr', then CallBuilder will
be responsible for building the function.  Use helper AST class:
'ASTExpr' with subclasses for AST and Expr.  Attaching an AST to an
AST yields another AST; attaching an Expr to an Expr or an AST yields
and Expr. -- refactor 'build' method.
