List of targets for each person.

A target is:
  time, x, y, rot.

Always animate w/ beat: either "keep time" (in place) or an
 appropriate amount of "press ahead", "sashay left", "sashay right",
   or "press back", depending on motion vector/facing direction.

              motion vec
facing dir | /
           |/__ <- sashay component.
           ^
           press ahead/back component.

Also need 'turn left' and 'turn right' movements.  All movements
should be two part (left foot, then right foot), but 1 beat = 1 step
(ie, half the cycle).  "Scoot back", for example, is 3 beats: 1 step
straight ahead, 1 turning step for trade, 1 step straight back.
So always interpolating between three keyframes, one for "x", one for
"y", and one for rotation.  (Writing animation for rotation will be
tricky: best start with spine rotating smoothly, then move all bones,
and then reset the rotation on the spine.)

Should use an independent timer to run camera homing, so that it not
dependent on song timing.  Current values are okay for 96<FPS<170.
** Rather than fixed rate pan/tilt, write an acceleration profile
which will return to 'home' in 1 beat.  Record distance from target
of 'last user override' (ie, change of view or manual pan/tilt).
Based on current distance, apply /\ acceleration (increase velocity
unless we're at midpoint, else decrease.)  Need some math to figure
out what the delta V should be, based on actual dist/total dist.

Should use frame-rate limited display: 15fps?  30fps?

Also, use relative vertex animation for: head turns, smiles, hand
movements.  These are cycles, but we subtract the frame vertices from
the start vertices to get a displacement, and then apply the
displacement over whatever else is going on.  Also 'dropping'
something, and sound effects (claps, etc).

If the dancers are left stopped without a command, they should
initiate a 1-2 beat (randomize start/end points?) head turn in the
caller's direction (limited by neck mobility) -- also eye turn?

Dancers should also look towards their partners if their partner is
'near enough'.


The checkers can have a walking animation, too, tilting up & down and
'walking' across the table.  Maybe include global translation/rotation
matrix in keyframining?
---------

More points for sequences near 'optimal length' (ie, not too long or
short).

Points for consistent flow (flow meter increases, reset to zero on bad
flow).

Points for continuous calling (same deal, or maybe a bonus for a
continuous resolved sequence.)

Dancers may 'drop' objects: points for getting the dancer who dropped
the item to the place where it (randomly) ends up within a certain
time period.

Difficulty level: tempo, dancer appearance (arky/identical),
'turkeys'.

Bonus for recovering after a turkey.

Maybe caller movement as well to receive bonuses.

Meters: instantaneous 'flow', 'sequence length', 'originality'.
Score is the integral of the instantaneous values.
Originality is scored via histogram: sort calls by frequency, and
display bar.  More points for 'flat' graph (no calls over- or
under-used), and per-call score is positive if call frequency is below
average or negative is call frequency is above average.


----
splice 'miditimers' together to allow switching tunes?
 each time measurement is a rational number; pass this rational number
 between timers atomically to ensure monoticity.  main timer is just a
 switch.

Support sampled sound (wav/mp3) via "beat maps" -- a list of
 (beat number, micro-second location) pairs which are smoothly
 interpolated to reconstruct beat number from the playback us
 location.
--
To switch songs: turn on the loop; when we receive the 'music end'
 signal switch to new song?

From FAQ: http://www.jsresources.org/faq_midi.html#note_event_notification
 Add Meta events at switch points (at measure or phrase boundaries).
 When we get one of these events, stop the sequencers and start the
 next. See http://www.jsresources.org/faq_midi.html#schedule_events
 for ideas on dealing with lead-in: to wit, chain two switches. Switch
 to a silent track with 3 of the 4 beats and then a META event, which
 will trigger the switch to the 1 beat pickup.
 See also http://www.ii.uib.no/~espenr/midistreaming/ w/ regard to
 swapping sequencers for gapless playback.
---------
photos of barn.
---------
resolve:
 search both backwards and forwards.
 initially discard rotation information ('at home' getout vs not)
  and search from both ends (from the start & from the goal)
  discard actual call info after each deepen; just preserve the set of
  formations reachable.  Then when showing results, we can re-do the
  partial search from begin formation to end formation to show
  options.  If we want an at-home getout, we can search w/in the
  results, not discarding rotation info this time.  This reduces the
  search space, since the forward-dancing stage doesn't have to
  separately consider states which are identical except for rotation.
  (Alternately, search state is tuple of 'dancer-independent'
  formation and a set of possible dancer orderings (since there are
  only 24 possible symmetric orderings).
 user UI should allow you to select 'at home getouts', 'promenade
 1/4', 'promenade 1/2', 'promenade 3/4', etc. for singers.

----
IN should be applied both bottom-up and top-down.  'Inherent' length
is propagated bottom up (where prim and part = 1, and IN resets to its
spec), and then outermost INs are applied top-down, with available
beats according proportionally to 'inherent' length.

call application should reduce to a tree of nothing but IN PRIM and
SELECT.  Otherwise keep tree as high as possible for concept application.

------
Multiple formation option (advanced rounds)
Keep a List<Formation> around.  If there are several possible calls in the
"top-N" recognition options list, flip a coin (based on their
respective probabilities) to chose which one each square does.
Probably need selectors like "back square" to make this more fun,
although maybe "those who can" is enough.  Squares ignore calls they
can't do (and glare at the caller) until they hear a 'forward and
back', at which point they make lines.
------
All call predicates take a 'DanceState' as well as the Formation or
whatever else they are operating on.  The DanceState contains info
like the current program (which should be an enumeration).
------
counter rotate (for example) is:
  from: MINI_WAVE
    condition: PROGRAM AT LEAST(a2) // is this right?
    call: _counter rotate
  from: COUPLE
    condition: PROGRAM AT LEAST(c1) // or whatever
    call: _counter rotate
When using counter rotate to define other calls, use _counter rotate
or counter rotate, depending on whether the use is program-sensitive
or not.
------
Use call grammar to do a typing interface as well: do the
selected-text-while-typing thing to display the possible lookahead.
Space accepts the current lookahead.
------
For animation of complicated sequences, treat dancers as connected to
their desired locations with a spring.  Sense collisions and stretch
the spring as necessary (ie, don't walk through people).  Should
probably treat dancers as circles so they don't get stuck on each
other.  Each path has a "shoulder direction" which says which way they
attempt to go around obstacles.
-----
Roll direction is 'rot' component of last PRIM. (Not counting
'standing still' PRIMS, which are 0,0,none, or sound effects, which
have timing 0).  Sweep direction is 'sashay' component of last PRIM.
-----
Eventually: sound effects.  Special type of prim with timing 0?
Same for actions? (sound effects are triggered at prim location,
while actions are centered at prim location).
----
fractionalization can only occur in a Seq of Parts, not between
prim calls, or in mixed lists.  the 'and' concept creates a
divisible part for each call.  IPART is an 'indivisible part'
(XXX: we don't currently check homogenity of a Seq)
----
add 'mod' to Rotation to yield general direction. rotations are
consistent if: they're exactly equal.  Effective modulus is always
1/N for some N -- reduce fraction to lowest terms, then use denom.
for example, a modulus of 2/3 is equivalent to 1/3, since the
sequence goes 2/3, 4/3 == 1/3 mod 1, 6/3 == 0 mod 1.
For rotations with differing modulus, check that d1 % d2 = 0,
where d1 is the larger denom and d2 is the smaller.
----
to do:
create plain-text parser (into APPLY trees)
add formation changes during Seqs to elaborate.
build dancerpath from simplified tree (PRIM/WARP/SELECT with numbered dancers)
animate dancer paths
  generalize rotation
----

Primitives coordinates can tell 'in' and 'out' modifiers, which
multiply by +1 or -1 depending on vector to current formation center.
This way we don't need separate rules for (say) circulate from RH and
LH boxes; they both move "+2in" in the sashay direction. (Directions
are 'sashay, ahead', aka x,y.

---------

Formation warps are independent stretches of x,y axes.

First: taking a canonical formation and stretching to accomodate solid
dancers:
  First we write down the x (y) axis coordinates of "inner" boundary
  edges.  The x (y) boundary edges around a dancer at x,y are at x+1,
  x-1 (y+1, y-1). We only use the boundary edge which is closest to
  the origin; we assume we can safely expand to fill space in the
  other direction (ie, the centers in a diamond can expand to fit
  tandems in the typical tandem diamond formation).

  Then, for each formation, we identify the x (y) coordinates which
  bound the formation.  These are the points in the "inner boundary"
  list which are <= and >= our boundary edges in this
  axis.  (Note that, because only the inner boundary coordinates are in the
  list, there may not be an exact match for our edge.)  We ensure that
  the bounds are large enough to accomodate the desired x (y) size of
  this dancer by adjusting the 'output' list for these bounds; any
  points lying between the bounds are stretched proportionally.
  We work outward from the origin in both the positive and negative
  direction, so no recentering will be needed.

For example, if the X 'inner boundary' list was: -2,0,2 and we had a
three dancer formation with bounds -1,1 which needed to be at least 6
units wide, then we might stretch the output list from -2,0,2 to
-3,0,3.  Note that we've adjusted the mappings for -2 and 2, even
though our bounds are -1 and 1.  Note also that, since the original
formation straddled the origin, that we had to stretch in both
directions.  Usually only one 'inner boundary' edge is pushed out.

When actually placing the new dancers in the square, we don't
individually warp their points: we just identify the inner bounds in the
list (-2,2) as before, map these (-3,3) and drop our formation
undistorted hanging off its inner boundary.

Second: taking a given formation and shrinking it given blocks of
solid dancers (similar to the above):

  First we write down the x (y) axis coordinates of inner boundary
  edges.  The x (y) boundary edges around a dancer at x,y are at
  x+(w/2), x-(w/2) (y+(h/2), y-(h/2)), where w (h) is the width
  (height) of the solid dancer.  The 'inner' edges are the ones closest
  to the origin (one in X, one in Y).

  We then renumber these shared edges so that there are exactly 2
  units between each pair of points.  We linearly interpolate using
  this correspondence to warp the center point of the solid dancer to
  create a new canonical dancer; the mapping ensures that dancers
  created this way will not overlap (well, there may be some edge cases).

Note that compressing a tandem diamond in this fashion will result in
a 'short' diamond (points at (0,+/-2) instead of (0,+/-3).  We
recognize this as an alternative diamond formation that can be
breathed into the standard diamond.
-----------
Dancers are diamond shaped:
  ^
 <+>
  v
with a 2-unit diameter.  This explains how stars can exist, but
aligned dancers can not be closer than 2 units apart.

-----------
FormationMatch should include both the formations matched, as well as
a 'meta formation' showing the arrangement of these.  Then, we apply
the calls in the subformations, and put the results together according
to the meta formation.

Each formation should also have a max size associated with it?  This
way we can give it extra space in the middle?  Think about 'lock it
twice' from parallel ocean waves.  Need to make sure we stretch in the
middle to accomodate the tidal wave.

(Maybe the reassembly should happen at each intermediate point?)

We generate a warp function which disassembles & then reassembles the
formations.
----------
elaborate should weed out inapplicable formations/evaluate conds, but
not do any irreversible rewriting.

The formation reconstruction which 'from' does is not currently
encapsulatable in a 'Warp' node.
---------

Handle collisions at the same time we do formation reconstruction: if
two dancers are on the same spot, replace them with a RH MINIWAVE
at that location.
---------

anything: LEFT leftable_anything // tight
	| REVERSE reversable_anything // tight
	| MIRROR anything // low
	| leftable_anything
	| reversable_anything
	| anything AND anything
	| anything AND ROLL
	;
	
leftable_anything
	: SQUARE THRU number
	;

//TANDEM (anything AND ROLL)

anything0: MIRROR anything1
	| anything1
	;
anything1: anything1 AND anything2
	| anything2
	;
anything2: anything2 AND ROLL
	| anything3
anything3: LEFT leftable_anything
	| REVERSE reversable_anything
	| anything4
	;
anything4
	: leftable_anything
	| reversable_anything
	| DOSADO
	| LPAREN anything0 RPAREN
	;
----------
how to deal with "swing and mix"/"and(swing,mix)" ambiguity?
Answer: post-process parse tree to create "(apply swing-and-mix)" from
"(apply and (apply swing) (apply mix))".
-----------
What about doing a "find all parses" with a truely ambiguous grammar?
We could do the same thing we do with speech recognition: try each
possible parse & discard any that don't work.
-----------

What about diamonds?  Two options:
 a) insist that every formation is 'compact'  -- this will move the
 points in from (0,+/-3) to (0,+/-2), and endangers the idea that
 centers are centers and ends are ends of crossed waves.
 b) Introduce some phantoms to hold space in the formation?  The
 reason that siamese diamonds work as:
     > >
     ^ v
     ^ v
     < <
  and the ends don't have to shift out is because there is still space
  for the two 'center' phantoms:

     > >
      x
      x
     < <

  so mark phantom positions in formations, and no real dancers need to
  match these, but they still hold space?  careful that they don't
  interfere with the expansion of the tandem in the center.
 c) formations have 'struts'?  points are held out by length-two struts?

ANSWER:
 When expanding a formation, use the "inside" edges to push out on
 only: never remove space from the formation.  This should make
 inserting tandems into a standard 2x4 diamond yield (effectively) a
 tandem 2x3 diamond.
 Second: whenever we try to match a formation and fail, try also to
 match "isomorphic" formations & insert a 'breath' operation if
 necessary.  Make 'small diamonds' isomorphic to 'big diamonds', just
 like 'quarter tag with ends facing right' is isomorphic to 'twin
 diamonds'. (and in some cases, facing couples are isomorphic to waves
 & vice versa).
--------
Formation elaboration does:
 * simplifies formations known to be impossible, given input.
 * evaluates conditions.
 * inserts explicit 'breathing' nodes into the AST when:
    diamond/quarter tag conversion needs to occur
    short diamond/big diamond
    facing waves/step to a wave (concept '_no touch' means delete the
     initial '1/2 pass thru' so that pass thru from a wave becomes:
       from: MINIWAVE
       call: _no touch(pass thru)
     swing thru from facing couples becomes:
       from: FACING COUPLES
       call: touch, swing thru
    multiple formations exist -- ie, call is from 'diamonds' and we
    have 'twin diamonds'.  This allows us to decouple the 'formation
    reassembly' from elaboration.

Formation evaluation results in a series of time-stamped formations.
Tricky: how to combine parallel movements.  Do we interpolate (along
a curved path if necessary), refuse to interpolate (or only
interpolate linear actions), or something else? (some formations
missing some dancers?  some formations have 'old' positions for
dancers, used only for formation reassembly, not ultimately for dancer
movement interpolation?)  Use octagon interpolation of curved
movements?

The following pythagorean triples form a 10-degree approximation to
a circle (see pythagoras.html):
 105, 608, 617
  51, 140, 149
 120, 209, 241
  88, 105, 137
 (and their transposes, switching a for b)
We could do linear interpolation between these points to interpolate
paths and facing directions using rational arithmetic -- or we could
just do the exact floating point computation, and use the Fraction
method which generates a rational from a double -- but will this result
in overflow?  The benefit of the rational approximation is that we
know that the denominators are < 1000, which gives us plenty of room.
