List of targets for each person.

A target is:
  time, x, y, rot.

Always animate w/ beat: either "keep time" (in place) or an
 appropriate amount of "press ahead", "sashay left", "sashay right",
   or "press back", depending on motion vector/facing direction.

              motion vec
facing dir | /
           |/__ <- sashay component.
           ^
           press ahead/back component.

Also need 'turn left' and 'turn right' movements.  All movements
should be two part (left foot, then right foot), but 1 beat = 1 step
(ie, half the cycle).  "Scoot back", for example, is 3 beats: 1 step
straight ahead, 1 turning step for trade, 1 step straight back.
So always interpolating between three keyframes, one for "x", one for
"y", and one for rotation.  (Writing animation for rotation will be
tricky: best start with spine rotating smoothly, then move all bones,
and then reset the rotation on the spine.)

Should use an independent timer to run camera homing, so that it not
dependent on song timing.  Current values are okay for 96<FPS<170.
** Rather than fixed rate pan/tilt, write an acceleration profile
which will return to 'home' in 1 beat.  Record distance from target
of 'last user override' (ie, change of view or manual pan/tilt).
Based on current distance, apply /\ acceleration (increase velocity
unless we're at midpoint, else decrease.)  Need some math to figure
out what the delta V should be, based on actual dist/total dist.

Should use frame-rate limited display: 15fps?  30fps?

Also, use relative vertex animation for: head turns, smiles, hand
movements.  These are cycles, but we subtract the frame vertices from
the start vertices to get a displacement, and then apply the
displacement over whatever else is going on.  Also 'dropping'
something, and sound effects (claps, etc).

If the dancers are left stopped without a command, they should
initiate a 1-2 beat (randomize start/end points?) head turn in the
caller's direction (limited by neck mobility) -- also eye turn?

Dancers should also look towards their partners if their partner is
'near enough'.


The checkers can have a walking animation, too, tilting up & down and
'walking' across the table.  Maybe include global translation/rotation
matrix in keyframining?
---------

More points for sequences near 'optimal length' (ie, not too long or
short).

Points for consistent flow (flow meter increases, reset to zero on bad
flow).

Points for continuous calling (same deal, or maybe a bonus for a
continuous resolved sequence.)

Dancers may 'drop' objects: points for getting the dancer who dropped
the item to the place where it (randomly) ends up within a certain
time period.

Difficulty level: tempo, dancer appearance (arky/identical),
'turkeys'.

Bonus for recovering after a turkey.

Switch one boy/girl pair in one square w/ two squares displayed; points for
resolving both squares correctly (using Dave Wilson's technique or another).

Maybe caller movement as well to receive bonuses.

Meters: instantaneous 'flow', 'sequence length', 'originality'.
Score is the integral of the instantaneous values.
Originality is scored via histogram: sort calls by frequency, and
display bar.  More points for 'flat' graph (no calls over- or
under-used), and per-call score is positive if call frequency is below
average or negative is call frequency is above average.
Should consider bigram and trigram distributions, so that we penalize
"modules".  Perhaps make suggestions for alternate calls, based on freqs?
(NO: score at measure or phase boundaries.  Meter is integral of "good and bad"
things; current meter values==score, applied at discrete points.  Also
"resolve" bonus.)

----
splice 'miditimers' together to allow switching tunes?
 each time measurement is a rational number; pass this rational number
 between timers atomically to ensure monoticity.  main timer is just a
 switch.

Support sampled sound (wav/mp3) via "beat maps" -- a list of
 (beat number, micro-second location) pairs which are smoothly
 interpolated to reconstruct beat number from the playback us
 location.
--
To switch songs: turn on the loop; when we receive the 'music end'
 signal switch to new song?

From FAQ: http://www.jsresources.org/faq_midi.html#note_event_notification
 Add Meta events at switch points (at measure or phrase boundaries).
 When we get one of these events, stop the sequencers and start the
 next. See http://www.jsresources.org/faq_midi.html#schedule_events
 for ideas on dealing with lead-in: to wit, chain two switches. Switch
 to a silent track with 3 of the 4 beats and then a META event, which
 will trigger the switch to the 1 beat pickup.
 See also http://www.ii.uib.no/~espenr/midistreaming/ w/ regard to
 swapping sequencers for gapless playback.
---------
photos of barn.
---------
resolve:
 search both backwards and forwards.
 initially discard rotation information ('at home' getout vs not)
  and search from both ends (from the start & from the goal)
  discard actual call info after each deepen; just preserve the set of
  formations reachable.  Then when showing results, we can re-do the
  partial search from begin formation to end formation to show
  options.  If we want an at-home getout, we can search w/in the
  results, not discarding rotation info this time.  This reduces the
  search space, since the forward-dancing stage doesn't have to
  separately consider states which are identical except for rotation.
  (Alternately, search state is tuple of 'dancer-independent'
  formation and a set of possible dancer orderings (since there are
  only 24 possible symmetric orderings).
 user UI should allow you to select 'at home getouts', 'promenade
 1/4', 'promenade 1/2', 'promenade 3/4', etc. for singers.

----
call application should reduce to a tree of nothing but IN PRIM and
SELECT.  Otherwise keep tree as high as possible for concept application.

------
Multiple formation option (advanced rounds)
Keep a List<Formation> around.  If there are several possible calls in the
"top-N" recognition options list, flip a coin (based on their
respective probabilities) to chose which one each square does.
Probably need selectors like "back square" to make this more fun,
although maybe "those who can" is enough.  Squares ignore calls they
can't do (and glare at the caller) until they hear a 'forward and
back', at which point they make lines.
------
All call predicates take a 'DanceState' as well as the Formation or
whatever else they are operating on.  The DanceState contains info
like the current program (which should be an enumeration).
------
counter rotate (for example) is:
  from: MINI_WAVE
    condition: PROGRAM AT LEAST(a2) // is this right?
    call: _counter rotate
  from: COUPLE
    condition: PROGRAM AT LEAST(c1) // or whatever
    call: _counter rotate
When using counter rotate to define other calls, use _counter rotate
or counter rotate, depending on whether the use is program-sensitive
or not.
------
Use call grammar to do a typing interface as well: do the
selected-text-while-typing thing to display the possible lookahead.
Space accepts the current lookahead.
------
For animation of complicated sequences, treat dancers as connected to
their desired locations with a spring.  Sense collisions and stretch
the spring as necessary (ie, don't walk through people).  Should
probably treat dancers as circles so they don't get stuck on each
other.  Each path has a "shoulder direction" which says which way they
attempt to go around obstacles.
-----
Eventually: sound effects.  Special type of prim with timing 0?
Same for actions? (sound effects are triggered at prim location,
while actions are centered at prim location).
----
fractionalization can only occur in a Seq of Parts, not between
prim calls, or in mixed lists.  the 'and' concept creates a
divisible part for each call.  IPART is an 'indivisible part'
(XXX: we don't currently check homogenity of a Seq)
----
to do:
create plain-text parser (into APPLY trees)
add formation changes during Seqs to elaborate.
build dancerpath from simplified tree (PRIM/WARP/SELECT with numbered dancers)
animate dancer paths
  generalize rotation
----

Formation warps are independent stretches of x,y axes.

First: taking a canonical formation and stretching to accomodate solid
dancers:
  First we write down the x (y) axis coordinates of "inner" boundary
  edges.  The x (y) boundary edges around a dancer at x,y are at x+1,
  x-1 (y+1, y-1). We only use the boundary edge which is closest to
  the origin; we assume we can safely expand to fill space in the
  other direction (ie, the centers in a diamond can expand to fit
  tandems in the typical tandem diamond formation).

  Then, for each formation, we identify the x (y) coordinates which
  bound the formation.  These are the points in the "inner boundary"
  list which are <= and >= our boundary edges in this
  axis.  (Note that, because only the inner boundary coordinates are in the
  list, there may not be an exact match for our edge.)  We ensure that
  the bounds are large enough to accomodate the desired x (y) size of
  this dancer by adjusting the 'output' list for these bounds; any
  points lying between the bounds are stretched proportionally.
  We work outward from the origin in both the positive and negative
  direction, so no recentering will be needed.

For example, if the X 'inner boundary' list was: -2,0,2 and we had a
three dancer formation with bounds -1,1 which needed to be at least 6
units wide, then we might stretch the output list from -2,0,2 to
-3,0,3.  Note that we've adjusted the mappings for -2 and 2, even
though our bounds are -1 and 1.  Note also that, since the original
formation straddled the origin, that we had to stretch in both
directions.  Usually only one 'inner boundary' edge is pushed out.

When actually placing the new dancers in the square, we don't
individually warp their points: we just identify the inner bounds in the
list (-2,2) as before, map these (-3,3) and drop our formation
undistorted hanging off its inner boundary.

Second: taking a given formation and shrinking it given blocks of
solid dancers (similar to the above):

  First we write down the x (y) axis coordinates of inner boundary
  edges.  The x (y) boundary edges around a dancer at x,y are at
  x+(w/2), x-(w/2) (y+(h/2), y-(h/2)), where w (h) is the width
  (height) of the solid dancer.  The 'inner' edges are the ones closest
  to the origin (one in X, one in Y).

  We then renumber these shared edges so that there are exactly 2
  units between each pair of points.  We linearly interpolate using
  this correspondence to warp the center point of the solid dancer to
  create a new canonical dancer; the mapping ensures that dancers
  created this way will not overlap (well, there may be some edge cases).

Note that compressing a tandem diamond in this fashion will result in
a 'short' diamond (points at (0,+/-2) instead of (0,+/-3).  We
recognize this as an alternative diamond formation that can be
breathed out into the standard diamond.
-----------
Dancers are diamond shaped:
  ^
 <+>
  v
with a 2-unit diameter.  This explains how stars can exist, but
aligned dancers can not be closer than 2 units apart.

(Not quite: this would mean that diamonds ought always to breathe into
stars.  More correct to say that stars, thars, and C1 phantoms are
special "crossed" formations with dancers occupying spots in a crossed
grid that lets them get closer to each other than they would otherwise.)

-----------
FormationMatch includes both the formations matched, as well as
a 'meta formation' showing the arrangement of these.  Then, we apply
the calls in the subformations, and put the results together according
to the meta formation.

Think about 'lock it twice' from parallel ocean waves.  We need to
reassemble the formation in the middle to accomodate the tidal wave.
(Maybe the reassembly should happen at each intermediate point?)

----------
elaborate should weed out inapplicable formations/evaluate conds, but
not do any irreversible rewriting. (No.)

The formation reconstruction which 'from' does is not currently
encapsulatable in a 'Warp' node. (I think I'm getting rid of the
'Warp' idea, except perhaps for smooth animation of (say) once-removed.)
---------

We handle collisions at the same time we do formation reconstruction: if
two dancers are on the same spot, replace them with a RH MINIWAVE
at that location.
---------

anything: LEFT leftable_anything // tight
	| REVERSE reversable_anything // tight
	| MIRROR anything // low
	| leftable_anything
	| reversable_anything
	| anything AND anything
	| anything AND ROLL
	;
	
leftable_anything
	: SQUARE THRU number
	;

//TANDEM (anything AND ROLL)

anything0: MIRROR anything1
	| anything1
	;
anything1: anything1 AND anything2
	| anything2
	;
anything2: anything2 AND ROLL
	| anything3
anything3: LEFT leftable_anything
	| REVERSE reversable_anything
	| anything4
	;
anything4
	: leftable_anything
	| reversable_anything
	| DOSADO
	| LPAREN anything0 RPAREN
	;
----------
how to deal with "swing and mix"/"and(swing,mix)" ambiguity?
Answer: post-process parse tree to create "(apply swing-and-mix)" from
"(apply and (apply swing) (apply mix))".

More tricky parses:
 <designator> (<anything> and <anything>)
 (<designator> <anything>) (and|while the) (<designator> <anything>)
 "swing and (TANDEM mix)" vs. "TANDEM (swing and mix)"
                          NOT "(TANDEM swing) and mix"
Use greedy parse?
or:
 <anything1> = <designator> <anything2>
             | <designator> <anything2> AND <designator> <anything2>
 <anything2> = <anything2> AND <anything2> // ie, no designators allowed here
 <anything3> = LPAREN <anything1> RPAREN

-----------
What about doing a "find all parses" with a truly ambiguous grammar?
We could do the same thing we do with speech recognition: try each
possible parse & discard any that don't work.
-----------

Whenever we try to match a formation and fail, try also to
match "isomorphic" formations & insert a 'breathe' operation if
necessary.  Make 'small diamonds' (points at (0,+/-2) isomorphic to 
'big diamonds' (points at (0,+/-3), just
like 'quarter tag with ends facing right' is isomorphic to 'twin
diamonds'. (and in some cases, facing couples are isomorphic to waves
& vice versa).
(Alternatively: the Selector for diamonds also recognizes the
alternatives, and inserts a breathe operation.)

Also "heads r&l thru" from squared set results in a quantum
superimposition.  Challenge dancers would be a 2x4; mainstream dancers
would be back in a squared set.

--------
Formation elaboration does:
 * simplifies formations known to be impossible, given input.
 * evaluates conditions.
 * inserts explicit 'breathing' nodes into the AST when:
    diamond/quarter tag conversion needs to occur
    short diamond/big diamond
    facing waves/step to a wave (concept '_no touch' means delete the
     initial '1/2 pass thru' so that pass thru from a wave becomes:
       from: MINIWAVE
       call: _no touch(pass thru)
     swing thru from facing couples becomes:
       from: FACING COUPLES
       call: touch, swing thru
    multiple formations exist -- ie, call is from 'diamonds' and we
    have 'twin diamonds'.  This allows us to decouple the 'formation
    reassembly' from elaboration.
(Mm, not quite?)

Formation evaluation results in a series of time-stamped formations.
Tricky: how to combine parallel movements.  Do we interpolate (along
a curved path if necessary), refuse to interpolate (or only
interpolate linear actions), or something else? (some formations
missing some dancers?  some formations have 'old' positions for
dancers, used only for formation reassembly, not ultimately for dancer
movement interpolation?)  Use octagon interpolation of curved
movements?

The following pythagorean triples form a 10-degree approximation to
a circle (see pythagoras.html, which has a 5-degree approximation as well):
 105, 608, 617
  51, 140, 149
 120, 209, 241
  88, 105, 137
 (and their transposes, switching a for b)
We could do linear interpolation between these points to interpolate
paths and facing directions using rational arithmetic -- or we could
just do the exact floating point computation, and use the Fraction
method which generates a rational from a double -- but will this result
in overflow?  The benefit of the rational approximation is that we
know that the denominators are < 1000, which gives us plenty of room.
---------------
Use the Sphinx RuleGrammar to parse our inputs, rather than having a
separate ANTLRv3 grammar?  cons: Sphinx doesn't recognize ambiguity
in the grammar.  pro: it (seems to have) no problem with left recursion.
---------------
1. Each movement ought to be interpolated according to the momentary center of
the (sub)formation - ie, box counter rotate is an arcing movement, not a a
straightforward prim 0,2,right (for trailer in right hand box).  This is
important for roll/sweep and flow.
2. Post processing at SELECT (ParCall) should insert handhold actions for
connected dancers.  Actions are "left hand hold" and "right hand hold".
3. Evaluate returns list of "Prim or Action" per Dancer; these are applied
during SELECT (ParCall) processing to yield a formation.  (Separate class
does the combination from the sorted list of time steps).  Note that we may
need to interpolate paths in order to get a uniform set of steps; ensure
that crossing paths will actually result in identical locations for the
relevant dancers -- tricky for t-boned jaywalk.
4. Be careful to distinguish between 'general formations' and disjunctive
   selectors.  Use general formation where possible, and use GENERAL in the
   name of the selector.  BOX and OCEAN_WAVE can't be general selectors.
5. NEAR WAVE / NEAR LINE / FAR WAVE / FAR LINE tags?
-----
Circular interpolation algorithm:
 0. If motion is explicitly tagged ("ARC") then use formation origin as
    arc center.  Otherwise:
 1. Get intersection of lines perp. to motion at start and end.
    If no intersection, then bail to straight line path.
 2. Check whether intersection is to left or right of motion direction,
    at both start and end.
    If intersection point is colinear with motion direction, bail to straight
    line path.
 3. If both left or both right, then arc is possible: center is at intersection
    point.  Otherwise, bail to straight line path.
-----
After SELECT fails, we go to a 'try harder' phase, where we try to find the
appropriate tags, irrespective of the current TaggedFormation.

After FROM fails, we 'try harder', which involves trying breathing and applying
"from facing couples" and "from waves" rules.  Need explicit tag in call
definition to say when this is/is not applicable?  Ie, recycle from facing
couples not okay using "from facing couples" rule.
----
Add audio feedback element to Sphinx frontend pipeline, between
edu.cmu.sphinx.frontend.util.Microphone and 
edu.cmu.sphinx.frontend.endpoint.SpeechClassifier.   Look at the
SpeechClassifer for ideas: it is estimating input level as well; we just need
a shorter time constant.  Alternatively, grab audio after the
edu.cmu.sphinx.frontend.endpoint.SpeechMarker; then we can use different
colors for non-speech (grey with high alpha) and speech (primary
color) data.
----
HUD To-Do:
 support for scrolling "measure end" and "call stars"
----
Use ChaseCamera to 'chase' the center of the set.

During menu modes, slowly rotate the camera around the set.  Slew to
chase position when game starts.
----
Bonus formations on right.
Suggestions for 'new' calls you can do presently also on right.  Part
of 'tutorial'.  Can select "help" level.   Always give suggestion when
stalled.

Better error messages for calls. "Boys and Girls must be together" or
"only from waves or facing couples" eg when caller gets it wrong.

try to teach caller w/o having to rely on outside references?
----
Should add package.html files.
----
ScoreAccumulator should get updates when the dancers are waiting for
their next call, as the "timing and flow" meter should continue to run
down while they wait.  ScoreAccumulator 'goodCall' method should just
be responsible for the jump in "timing and flow" when a good call is
given.
---
Sphinx states like GameStates; pass Results around from each (since we
need different result processing in different states).

"Say "square up" or press enter to start" w/ high "out of grammar
utterance" probability.

Menu: microphone selection and volume (virtualize Sphinx "Microphone"
component?), # of dancers (4/8/12 <- "at home" really is at home for
everyone), dance program (basic->c4), judging (easy/medium/hard).

"Poor man's SD" (PMSD) interface, with text i/o to call engine.
(java.util.Scanner)
--
Integrate with DDR game?  Maybe generate step sequences based on calls &
timing, so that the caller is effectively dynamically generating step
sequences.  Other ideas: 4x4 grid of DDR pads?  Step on facing direction?
---
Rewrite TextureText to generate triangle strips and a non-sheared texture.
How do we make the bounding box actually match up?  Generate 10% extra and
then dynamically shrink?  Maybe use different means to get text width?
---
Moderate volume level of MidiThread!
---
Wrap BeatTimer so that it returns 0 until music is started up; this will
allow us to delay music startup until after Venue (ideally, music would
start when the menu comes up, so that user immediately has the option to
turn it off or adjust the volume).
---
At the moment we're using the Java Sound API for recording/playback.
For fancier (& hardware-accelerated) playback, we could switch to
OpenAL, which lets us do doppler-shifted positional sounds & other fun
stuff.  OpenAL 1.1 has a capture interface; look for
alcCaptureOpenDevice & friends.  To enumerate capture devices, call
alcGetString(NULL, ALC_CAPTURE_DEVICE_SPECIFIER).
  xxx: this results in a very limited list of capture devices:
         '((device '(native))
       no way to select microphone vs line in vs usb mic.
---
For midi output, we don't need to manually set
Transmitters/Receivers/etc. Look at MidiSystem.getSequencer(true);

----------------------
Selecting ends/centers etc depends on matching a specific formation.
So: FROM xyz SELECT pdq.
FROM converts the Formation to a TaggedFormation.
SELECT w/o a controlling FROM can fail.
FROM is an explicit "re-evaluate".
---------
Add "designated dancer" concept which adds the appropriate DESIGNATED
tag.  Should this tag be preserved within a FROM?  If so, a property
of Position. I think actually we'd do something like:
def: <designated> run
  from: COUPLES
    call: _designate(<designated>, _run)
ie, the designate concept would already have a TaggedFormation to work
with, so this can be a TaggedFormation.Tag, not a Position.Flag.
--------
Elaborate should do "one step" of the call at each invocation.
-------
Need a "as N steps" version of Part, to make square through, swing and
mix, etc work right. (or an _expand concept, to make the parts of the
subbits though through.  So, swing and mix is: swing, _expand(mix)
which becomes: swing, centers cross run, new centers trade; ie three
parts.  swing, mix would become two parts: part(swing), part(centers cross run,
new centers trade).
-----
Evaluate has a stack of evaluators
  each has a child elaborator (with its own call stack to work on)
  and a continuation call stack.
Ie:
 "(tandem trade) and roll, then double pass through"
StandardE -> Tandem -> trade (standardE?)
                    \roll
           \double pass thru
"one part" of evaluation (assuming trade has two parts) yields:
StandardE -> Tandem -> [finish a trade]
                     \roll
           \double pass thru
"one more part":
StandardE -> roll
          \ double pass thru
"one more part"
StandardE -> double pass thru
--
Concepts can either: (a) apply a transformation to their arguments, and
then disappear, or (b) install themselves in the evaluator stack, as
an ongoing filter on the movements (like tandem would be).  Option
(a) can also be implemented by doing the transformation and then
invoking the standard evaluator on the result.
--
We have a special "_boring" call which is used as the continuation
when it would otherwise be null.  It's defined something like:
 call:
   from: ANYTHING
     if: _nothing_on_callstack
     nothing
     _expand(_boring)
   from: ANYTHING
     /* else */
     nothing
     /* fall off bottom here */

This keeps the continuation non-null (by filling it as needed), and
can be extended to have various placeholder actions performed by the
dancers while they are "waiting" -- ie, california twirl with each
other, swing, partner trade twice, scootback twice, etc.  We probably
need a _random predicate to gate these behaviors.
---
Regular tick, at each tick add points according to the current
flow/difficulty/etc meters and the current bonus multipliers.
Bonus multipliers for "hard material" and "flowy material" --
each dance floor is different, some may like the hard stuff and
not care about flowy; some may want flowy and not care for hard
stuff.
"Hard sequence: 2x"
Calls and concepts can get "difficulty" annotations, which probably
multiply together to get the nested difficulty level.  ie "tandem as
couples trade" is a little hard, "tandem as couples (single wheel and
roll)" is pretty hard (since single wheel has higher intrinsic
difficulty than trade).
---
For flow, we're going to compute scores for each dancer individually;
the overall flow should be the "minimum of all the moving dancers".
You only get good flow if it's good for everyone (but people standing
still don't count for or against).
--
double pass through = <nothing> _atc
_atc is a specially recognized call that is search-and-replaced by the
various tagging modifiers; it means "double pass through" if
unmodified.
---
special selectors for certain formations: diamond might also introduce
a "points point in" action in addition to handling the different
alternate diamond shapes.
--
"do your part" == split state into two, each with just the appropriate
dancers selected.
 Thought experiment: what if GeneralFormationMatcher always tried to match
 against Formation.onlySelected() first; if that fails, it would
 try matching with the whole formation.
    a) The "partner trade" in a "CENTERS trade, ENDS circulate"
       matches just the two centers, good, and
    b) "BEAUS walk, BELLES dodge" from facing lines fails to match a box
       against just the beaus or just the belles and uses the whole
       formation, good, BUT
    c) from two faced lines, all the belles could end up forming a box
       of their own in the center.  That would be surprising.
This isn't a good thought experiment, because in the walk/dodge case
there isn't really an additional FROM operation after the SELECT
BEAUS/BELLES.

But for simplicity of the model, let's say that SELECT is *always* a
"do your part" with the rest of the formation included (ie, dancers
selected has no effect on FROM), so that acey deucey must be:
  "CENTERS (centers trade), ENDS circulate"
otherwise the centers would do their part of a partner trade with the ends.
(We do "select" the interesting dancers, so that we can only apply
prims to the selected dancers, but that's our only use of the
selected set in Formation.)

YES -- Sue mentions that a strict definition would be CENTERS
(concentric trade) while the ENDS circulate (or concentric circulate)

It may be that CENTERS/ENDS (as opposed to other <anyone>/others)
wants to try a "concentric" first, the regular evaluation if it
doesn't work.  This way "centers trade, ends circulate" will Just
Work, but "centers concentric trade, ends circulate" will also work.
---


SELECT marks a "re-evaluation" point.  Take the *breathed* version of
the formation at that point.

DanceState might want to distinguish between the *breathed* formation
(which is animated, and corresponds to where the dancers "really" are)
and the *unbreathed* formation (which corresponds to where the dancers
*think* they are).  For example, in facing star turns in a plenty, the
dancers are thinking that they are in a box at all times, even though
in actual practice they go through this weird crash state.  The PRIMs
for pass thru and trade are written as if you don't crash; if you
resolve the crash in the middle you'll end up someplace weird, even
though you want to animate with the crash resolved.  It just doesn't
affect your final position.

In actuality, the facing star turns are an example of "DO YOUR PART"
which consists of replacing all of the other dancers with
directionless phantoms.  In this case, a SELECT will match the *first*
of the formations possible.  So if you want "DO YOUR PART SPLIT
CIRCULATE" to assume a rh-box in preference to facing couples or
waves (since when you phantomize all but one dancer these are
legit matches), then make sure the RH BOX is first in the SELECT.

For evaluating SELECT, we should have a data structure which lists all
the DancerPaths for a particular dancer in order.   Then to obtain the
breathed dancer paths, we just iterate through them, replacing the
to() and from() with BreathedFormationAtTime[to].location(d),
BreathedFormationAtTime[from].location(d).

(We probably don't have to actually keep the breathed formations
around at all times: we can just create them on demand when the
caller invokes breathedDancerPaths() or breathedCurrentFormation()
(this latter call should be what SELECT matches on).
---------
Grammar ambiguities:
* 'and' as a call joiner, and in calls such as:
   scoot and dodge
   scoot and weave
   wheel and deal
   wheel and <anything>
   <anything> and roll
   <anything> and circle n quarters
   step and fold
   step and step
   step and slide
* (square thru 3) 1/2 times
  (square thru) 3 1/2 times

To handle these:
 * we don't allow 'and' as a call joiner.  It is only used in compound
   calls.  Thus: "swing and mix" is only ever a compound call, never
   (swing) and (mix).  "swing.  mix." (or "swing; mix") is the compound call.
 * "do the following (n>1) times"
   "do (n<1) of a <anything>"
   "half trade"
   "two-thirds recycle"
   "<anything> (n>1) times"
   is the grammar for fractional.
   Thus "square thru 3 1/2 times" is only (square thru) 3 1/2 times.
-------
Need a 'left means mirror' flag, and translate some of the (eg)
mirror(_touch(1/4)) uses in basic.list to left(_touch(1/4)).
------
U-turn back needs a "match with phantoms" operation which will match
couple/miniwave and single dancers, so we can do:
  from: GENERAL_COUPLE_AND_PHANTOMS
    from: COUPLE
     ...
    from: MINIWAVE
     ...
    from: SINGLE_DANCER
     call: face in and roll
    from: SINGLE DANCER
     ...face in, warn about roll direction
---
same for cast 1/4, which should match GENERAL_COUPLE
---
calls movements start/end in directions other than the facing
direction.  Eg: half of a rollaway ends in sashay direction, and a
full rollaway ends *walking backwards*.  I've added sashay tags to
those movements involving sashay.  Calls involving walking backwards:
  dosado, rollaway, half sasay, "back up walk, <others> dodge"
Also note: "stable", where even though the facing direction changes,
we must take care to preserve the dancer path tangents.  Hence add
sashay tags as needed, and assert that either 'sashay' or 'not sashay'
results in the same dancer path tangent as the unstable movement.
---
PMSD:
sdr> /set formation = 2 couple
3Gv 1Bv

1B^ 1G^
sdr> trade
3B^ 3G^

1Gv 1Bv
sdr>

also write doc tests like this.
/set IDENT = (.*)
maps to PMSD.setIDENT(str)
we can use a very simple grammar then (or none at all); we don't need
to teach the grammar about all the possible options one might set.
(maybe even PMSD.cmdSet(line), which allows implementing /save as
PMSB.cmdSave(__);
ALTERnatively: /js <javascript expression>

How 'bout: evaluate inside an implicit
with(State) {
}
context in javascript.  exit/restart, etc can be property getters (!)
on the State object, so:
: exit
: restart
etc works -- ie, no parentheses for simple commands.

Does javascript have a prompt mechanism?  How much of PMSD can we
write in javascript?
--
Selectors should have two parts:
 - "Apply adjustment()"
    returns the adjustment call necessary to use this selector (if any)
 - "Selector additional()"
    an additional selector to try, after others have been tried
    (that way they don't override user's custom selector ordering)

(maybe not separate adjustment/additional, maybe just return a list of
possible 'adjust' calls, try normal, then perform an adjust and
reattempt, etc.)

Opts maintain a FIFO queue of the provided and additional() selectors.

WAVE selector returns an additional() which has 'touch' as an initial
adjustment.  (Note that left swing thru must be "left(swing thru)" in
order to properly make the touch a left touch.)

DIAMONDS, etc have "ends in" adjustments (maybe always).

FACING COUPLES is tricky: the adjustment only applies if the call
starts with a pass thru.  So we have a special:
  FACING_COUPLES_WITH_PASS_THRU selector which returns the formation
  after the touch, with an adjustment that does 'nothing' from
  RH_WAVES and 'touch' from FACING COUPLES.  (Pass thru is tricky:
  note that it's a FACING DANCERS call, not just a FACING COUPLES
  call.  XXX: is the "step to a wave and" adjustment also from
  FACING DANCERs?

We're trying to be extra careful with RECYCLE, for which the "step to
a wave and" and "rear back" adjustments don't apply.  That's why we
have a FIFO queue, to allow the user's explicit selectors to override.
But maybe we'd be better off just having explicit NO_ADJUST versions
of the selectors, using the adjustment() method and ditching the
additional() method?

*OR* just require calls to manually specify the possible adjustments.
any call from ocean waves also has a "from: FACING COUPLES" variant.
Maybe automatically generated using a call flag?
-----
BadCallExceptions:
  they should have messages and priorities.
  The condition operator in the call definitions should take an
  optional explanation parameter, such as "facing couple recycle is
  not allowed below A2" or "only cast 1/4 is allowed at mainstream".

These need priorities, so that ordinary "formation doesn't match"
exceptions from a SELECT don't prevent the desired message from
getting thru.  The SELECT should, if nothing matches, through a
new exception with default priority that says, "Bad formation:
requires MINIWAVE, FACING COUPLES"
----

call completion:
add phase to BuildGrammars to build a repr() of the final Grm rules,
since we don't want to have to redo the precendence and left recursion
transformations.  Now match, but only expand nonterminals if there
isn't already at least one terminal in the "string so far".  IE:
   do 1/2 of a |<anything>
(where | indicates the division between "typed so far" and the
completion) would give some suggestons for the anything, and
  |<anyone> run
would give suggestions for anyone, but
  boys wa|lk <anyone> dodge
would leave anyone unexpanded, and just complete to "boys walk " if
selected (and you'd then get suggestions for <anyone>.

Add a "pretty name" to the nonterminals, so that the grammar
transformations aren't exposed here.
We'd probably want to collect all the alternatives for a nonterminal,
so there was a simple <nonterminal name>-><Grm> mapping (not a multimap).

Our input stream should be lexed into tokens (regexp, mostly just
splitting on strings, but we might greedily assemble fractions).
In addition to the left context of complete tokens, we might also have
a unlexed right context (if the input stream doesn't end with a
space); this is used as an additional filter when trying to match
against terminals.  The final candidates can be applied to the
formation to determine whether they are actually possible given the
current formation -- if the candidate involves a nonterminal, we can
either bail and assume its appplicable, determine whether we can
generate *some* assignment to the nonterminal that would allow it to
be applied, or (compromise) look briefly inside the call def to
determine whether the nonterminal is involved in the outer SELECT;
if not we can attempt to perform the SELECT to approximate
applicability.

*DONE*
repr() method on Grm.
String,List<Integer> generate(List<Token> leftinput, String rightinput, List<Integer> last)
in concat: we pop from last and use this as our starting index into
seq. (if last.isEmpty() use 0)
on return, we push our current index onto the vector.
for ()*, we push 0/1 depending on whether we select or not (like ?).
We recurse into ourselves iff (a) we were selected and (b) left/right
input is not empty.  Otherwise, we just provide one continuation as an
option.  ie:
  trade -> "trade and roll"
  trade a -> "trade and roll"
  trade and roll -> "trade and roll and roll"
  trade and roll a -> "trade and roll and roll"

----
Eventually minify the *Grm by generating one file with shared Grm
objects.
List<Grm> table = new ArrayList<Grm>(size);
table.add(new Terminal('xyz')); // 0
table.add(new Terminal('pdq')); // 1
table.add(new Concat(table.get(0), table.get(1))); // 2
table.add(new Concat(table.get(0), table.get(2))); // 3
// etc.
BASIC.put('anyone_2', table.get(54));
 ** DONE **
----------------------------
Events in the GWT UI:
 - add a call (at position X)
 - delete a call
 - change selected call
 - "refresh" (ie, when program is changed, or when calls are loaded)
 - 'animation tick'
List:
 for each dancer, a list of <time, dancerpath>
 for each call <call, start time> (for animation)
 an index marking where the valid calls end
if we delete a call from the middle, we probably want to refresh the
whole list of dancerpaths, but it might be worthwhile to keep a
pointer at the first dancerpath for each dancer for a given call
(place to start deleting/recomputing from; may actually belong to a
subsequent call or point at the end of the list)
---
Rename 'cardinal' rule to "numeric_adverb" or "times"
-----
tag sequences in sdrweb.  automatic tags such as plus/ms/c3/c4 and
also based on starting/ending formation:
module/singer/reverse singer/resolved/unresolved
(at home, 1/4 prom, 3/4 prom?)
should be able to sort/search based on tags
----
Use 'square expansion factor' (horiz and vertical) to smooth
animations so it doesn't look like we're always maximally breathed,
which makes trade from a tidal wave look weird, for example.
The idea is to keep the horiz & vertical dimensions of the square
constant (or decaying very slowly) by multiplying all x/y dimensions
by a scale factor.  So if we start out in a squared set (vert dim 8)
and do a 'heads lead right' (vert dim 4), we apply a vertical scaling
factor of 1.5 so that we end up in a breathed out setup with vertical
dimension 6.  A pass thru from here would go through a horizontal
setup of dimension 4, but we'd breathe that out to 6, and end up in an
8 horizontal by 5 vertical setup (halving the vertical scaling factor
again to approach 'true' 4.
This could even be entirely post-processing in the animation code so
that a formation gradually breathed inward to 'true scale' as you
let it sit. (ie, animation code keep 'true width' and 'expanded width',
setting expanded width to true width if true width is larger,
otherwise gradually letting expanded width decay towards true width,
halving the difference every second.
   diff = diff * (1/2)^(seconds since last update)
Halt anim loop when diff < epsilon.
----
"_blend(x,y)" concept which fractional knows it can discard; it just
discards an intermediate point in the dancer path between x-start and
y-end so that we do the action "in one fluid motion".
e.g. pass the ocean is usually animated as:
  _blend(pass thru, quarter in), extend
and square thru as:
  _blend(pass thru, quarter in), left sq thr N-1
and even cross trail thru as:
  _blend(pass thru, half-sashay)
---
to do:
 x) finish hexagon transform: rework so that winding # is exact, and
    always exactly equal (mod 1) to ExactRotation.from(X,Y)
    Keep separate "rotation offset" as well to account for initial
    rotation (don't try to combine in winding #)
    Then adjust *both* the winding number *and* the facing direction
    adjustment to "real" angles (radians) before requantizing for
    display.
 b) implement square expansion as a dancerpath transformation too
    (these are vaguely like concepts, but maintain persistent state)
    width/2, height/2 should remain constant.  this transform applies
    *before* hexagon transform (since properly expanding a hexagon
    in its three axes is much harder!) *careful about fraction
    overflow* probably want to use linear relaxation instead of
    "half each time"
 c) settle the SELECT/FROM question.  I think that *select* selects
    dancers, and only the selected dancers move, but that *from*
    *ignores* the selected status of the dancers.  Use a separate
    concept for "ignore non-selected"
    * We'll probably need a "non-breathing from" selector at some
      point to make it easier to define calls!
      - "breathe before match" == property of the selector?
      - so we can define ANY_BREATHE and ANY_NO_BREATHE?
      - what about breathing *after*, like we do for the top-level?
    * need to audit our use of the formation/selected concept. remove it?
 x) fix breathing: we seem to be letting dancers' bounding boxes
    overlap during insert, and trade from a two-faced tidal line
    should *not* create triple boxes (ie, the formations should
    remain centered during the insert)
 x) fix whatever I broke with the RemoveIn transformation recently
 f) use priority sensibly when displaying error messages
    I think the rule should be to display all the priority N messages,
    where N is the highest priority encountered?  Probably just
    passing up the single high-priority message would be sufficient.
    Maybe an ErrorAccumulator class, where you shove a
    BadCallException in and it takes care of formatting the "cause
    tree"?  Or create the full tree, and have a separate "friendly
    error" class (which pulls the one most useful/highest pri message)
    and "error detail" class (which shows the whole tree, like we're
    doing now)
 x) centers/ends.  heads/sides
 xx) make heads/sides part of the 'anyone' grammar production.
     (have to remove the hard coded 'heads <foo>' rules)
 g2) _anyone_others concept: "do your part"?
 x) concentric/quasi-concentric
     use CENTER_HALF selector, remove those dancers and breathe the
     remaining ones.  Now do the call in both of the resulting
     formations.  Open up a vertical/horizontal line (depending on
     concentric rules) in the resulting 'ends' formations and squeeze
     the centers back in there.
 h1) fix axis adjustment in concentric
 x) tandem
 i1) fix roll/sweep in tandem/as couples/etc.
 x) test circle left/right, test run (in all its glory), test trade
    from quarter tag
 j1) t-boned cross runs (needs select X&Y, see (w))
 j2) trade from quarter tag. (needs selector from multiple formations (y))
 xx) separate insertion point and playback cursor.
 k2) have a 'keep playing' flag that is set when you press play but
    cleared when you manually scrub to a point. if you receive more
    call data and were stopped at the end but the 'keep playing' bit
    is set, start playing. (see git e5f9f473b591a678d71ee6b385596034cd61833f)
 x) peel the top, from boxes and zees
 xx) "ends fold" is broken.
 m) diamond circulate, w/ adjustment from 'half of ends cross run'
    position. Probably should switch to breathed diamond spots. (see (aa))
 m1) peel the top ending in diamond ("do half a peel the top")
 n) roll failures (roll/trade-and-roll tests):
 n1) top-level evaluator should clear all roll directions if next call
     is not 'roll' (or other roll-dependent call -- by golly?)
     * or maybe should have separate 'nothing-clear-roll' and
       'nothing-keep-roll' calls, and use 'nothing-clear-roll' in
       places like the <anyone> <anything> concept and for the
       non-moving dancers in 'trade down the line'
     * SD says: "When "roll_transparent" is used on a part of a "seq"
       definition, that call must have the property that anyone who is
       marked roll-neutral (that is, with an "M" roll letter), must
       not have moved at all, and must consider this part not to have
       applied to him, so that the call "roll" will direct him to use
       the roll direction arising from what he did previously.  The
       call "centers hinge" obeys this property, and so the
       "roll_transparent" flag is appropriate.  The purpose of this
       flag is to make the centers hinge part of peel/trail to a
       diamond work correctly, so that the new points can roll."

 xx) roll should breathe before trying to roll, otherwise it can
     screw up collision resolution.
 p) CFLAG1_FUDGE_TO_Q_TAG from Sd/database.h:
    // setup is to fudged from a suitably populated 3x4 into a 1/4 tag.
    // The intention is that one can do "plenty" after doing a "1/2 press ahead"
    // (as opposed to the more natural "extend") from waves.  It also means
    // that we can fudge the other way if the schema is schema_in_out_triple
    // or schema_in_out_triple_squash.  See the call "quick step part 2".
    // It also means that a short6 is to be fudged to a 2x3.  See the call
    // "quick step part 1".
 x) define LEADERS/TRAILERS/BEAUS/BELLES in 2x2 selector.
    (and retest first part of peel the top)
 r) compute coverage metrics over the call definitions
    - make fake classes for coberatura:
      ClassData cd = net.sourceforce.coberatura.coveragedata.ProjectData
                     .getGlobalProjectData()
                     .getOrCreateClassData(fake_package_and_class_name);
      cd.setSourceFileName(real_file_name);
      cd.touch(line_num)
    - preserve source file / line # for ast nodes (at least FROM/etc)
    - in evaluator, touch the appropriate source file/line # (code above)
      on *successful* evaluation, ie, when we're sure we're not going
      to throw a BadCallException (hard?)
      - collect "lines touched" set and pass up to top level, so we
        can touch only the lines which were part of a successful Opt.
 s) EQUALS/CALL_IS => NUM_EQUALS, STR_EQUALS
    SELECTION_PATTERN => PATTERN_EQUALS(PATTERN(SELECTED), '_x__')
     (add 'don't care' character -- '?' or '.')
    PATTERN(ROLL) => 'rlrl', PATTERN(SWEEP) => 'rlrl'
    use PATTERN(SWEEP) to define "sweep 1/4" (FROM FACING COUPLES:...)
 t) add post-condition nodes to graph, evaluated as "do child, then
    test condition on resulting formation".  IfAfter() or maybe just
    a boolean in the If node for "eval after".
    -- allow 'ends in:' as a special case of this
    -- 'ends in' could eventually be used to choreograph backwards:
       take the current formation, match against all the known ends
       in, for those that match look at their 'from' clauses and try
       all 96 possible symmetric permutations to find the one which
       results in the current formation.
 xx) reorder defs to match callerlab docs
 v) 'from' takes flags
 w) 'select' is or-of-ands.  'select: DESIGNATED & BEAU, DESIGNATED & BELLE'
 x) _circle choreo concept that automagically adjusts 1/8 off circles
      do a 'circle left 1/8', then do the call and rotate all the
     intermediate formations right 1/8, then circle left 1/8 the final
     formation unrotated, to snap to squared set spots again.
 y) siamese concept -- multiple simultaneous formations in
    GeneralFormationMatcher
 z) Breather.breathe() should look at facing directions, and if
     they're 1/8 off, rotate,breathe,unrotate.
 aa) diamond/quarter tag conversions
     -- automatic in the diamond/tag selectors?
     -- use the multiple-formation matcher, then adjust the results to
        canonical shape?
 bb) facing couples/wave (and vice versa) conversions.
     -- do these manually for appropriate calls? (handles recycle)
-------
heads x:
  from squared_set:
    heads start
    centers x
  from: any
    select: heads
      call: ignore(sides, x)
centers x:
  // try to do the call concentric if possible.
  from: with_centers
    select: centers
      call: concentric(x)
  from: with_centers
    select: centers
      call: ignore(ends, x)

-------
FROM: <selector>
  usually a formation, but may be things like "with_centers"
  match results in: (a) subformations and a meta-formation which shows
  how to combine them, (b) subformations are tagged, which gives
  dancers tags.
SELECT: <tag>
  the specified dancers "do their part" *not ignoring others*
there's also an "ignore" concept, which gets rid of the specified
dancers from the formation.

e.g.
 from: RH_OCEAN_WAVE
  select: centers
   call: trade
  select: ends
   call: circulate
---> results in same place as "center run"

 from: RH_OCEAN_WAVE
  select: centers
   call: walk and dodge
  select: ends
   call: split circulate
--> 3 and 1 lines

 from: RH_OCEAN_WAVE
  select: centers
   call: concentric(trade)
  select: ends
   call: concentric(circulate) // or just circulate
--> acey deucey

 from: RH_OCEAN_WAVE
  select: centers
   call: ignore(ends, trade)
  select: ends
   call: circulate
--> acey deucey
--------
http://www.lynette.org/dconcepts.html
---
do your part -- tricky, should ignore illegal collisions (or all
  collisions) with the 'phantoms' who aren't doing your part.
  needs thought, especially for 'do your part of half a trade' from
  couples, where we're depending on collision to result in miniwaves?
  "do your part pass thru" do you dodge out of the way of the phantom?
  "do your part 1/2 a pass thru" -- clearly you expect waves here.
so i guess it's just "illegal" collisions with phantoms which we'll ignore?
OR ELSE, we should do "ignore(others, your part)" which will make the
  others go away, which is okay for absolute actions? (need flag for
  these to suppress breathing on press ahead, eg).

"Do your part" isn't exactly <Par>, since in some cases you have to
replace "everyone else" with a directionless phantom in order to do
the call; eg,
  > V
  ^ <    "everyone do your part, partner trade"

Importantly here, we should probably suppress matches which consist
entirely of phantoms?  Which might mean that the 'corporeal' bit may
need to make a comeback, so we know what to complain about?
The GeneralFormationMatcher needs to add a facing direction to the
phantom when it makes a match.

-----------

Internal call node for "unapplied concept". -- use this to push (eg)
fan and fractional down through from: nodes. Curried: concept:
with_designators Also rename selectors etc to make sense?  Select=tag
and from=selector

Note when using select, you must define a whole call!  Your selected
dancers *and the phantoms* will be dancing, so make sure the phantoms
don't crash horribly

Run diff from kickoff.  In run if no designee in your formation, nobody moves.

x Add designator stack, tag, and with_designated concept.
x Redefine run in terms of designers_run

x Add parse function to PMSD.

Add a from-no-breathing node/concept (see (c) above)

For triple box, either suppress breathing at top level (breathed a
prop of formation?) or materialize phantoms (ie must always use
formation.dancers() not dancestate.dancers(). I think making breathed
part of formation is probably correct, so we don't breathe after
'press ahead' -- need to assert that press ahead doesn't result in
collisions

Write doctest asserting that sphinx grammar accepts a subset of what
the antlr grammar accepts (ie, generate N utterances from sphinx
grammar, and try to parse them all w/ the antlr grammar)
----
FROM: <formation>
  does two sorts of breathing: we (optionally?) breathe *before*
  attempting the match, and then we *center* the pieces and *breathe*
  the meta formation.
  At top-level we also breathe the output formation, almost as if we
  had a 'from: SINGLE_DANCER' at top level -- except we evaluate the
  child in the whole formation.

Want to be able to suppress:
  a) input formation centering (press ahead, fold, parts of run)
     way 1: 'absolute' flag on the FROM, ie:
             from: [ABSOLUTE] ANY
             works best with way 2 or 3 of (c)
     way 2: 'anchor' flag on position; breathing tries to keep anchors
            aligned during formation expansion, even if it means
            giving extra space to a formation
            (i was having trouble making the constraints for this work)
     way 3: '_find tags' concept or [NO SUB] flag on FROM, which
            says, "perform the match, but do the rest in the entire
            input formation (just transferring flags) not breathing at
            all. (note that 'ends fold' from parallel ocean waves
            needs breathing, maybe this is explicit, like
              from: BREATHING
                from: [NO SUB, ALLOW UNMATCHED] GENERAL COUPLE /* || */
                  select: DESIGNATED[BEAU]
                    prim: <fold over to 0, 1/2>
                  select: DESIGNATED[BELLE]
                    prim: <fold over to 0, 1/2>
                  select: OTHERS
                    prim: <nothing, clear roll>
            after breathing this results in the callerlab "z formation",
            like a column after a 1/2 press ahead.
            (ALLOW UNMATCHED must still have at least one match)

  b) breathe-before-match (to match triple boxes)
     way 1: move breathe-before into GeneralFormationMatcher.makeSelector
            (with an optional parameter to disable?)
            SelectorList can then define ANY_NO_BREATHING formations,
            TRIPLE_BOX would have the no breathing flag by default,
            etc.  Disable parameter might not be necessary, if you
            figure that TRIPLE_BOX is going to be a custom Selector anyway.
  c) top-level breathing (assert no collisions if doing so)
     way 1: insert phantoms to hold space
     way 2: "already breathed" flag on formation.
     way 3: only breathe @ top level if there are collisions.
