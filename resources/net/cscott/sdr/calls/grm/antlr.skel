header {
	package net.cscott.sdr.calls.grm;
	import net.cscott.sdr.calls.ast.*;
}
/** "Natural language" grammar for calls. */

class @CLASSNAME@Parser extends Parser;
options {
	k=2;
}

@RULES@
	
people returns [Apply a]
	: a=boys | a=girls | a=all
	;
boys returns [Apply a] { a = Apply.makeApply("BOYS"); }
	: "boys" | "men" ;
girls returns [Apply a] { a = Apply.makeApply("GIRLS"); }
	: "girls" | "ladies";
all returns [Apply a] { a = Apply.makeApply("ALL"); }
	: "all" | "everyone" | "every" "one" | "every" "body";
wave_select returns [Apply a=null]
	: "centers" { a = Apply.makeApply("centers"); }
	| "ends" { a = Apply.makeApply("ends"); }
	;
anyone returns [Apply a]
	: a=people | a=wave_select ;
number returns [Apply a=null] { Fraction f; }
	: f=a_number { a = Apply.makeApply(f.toProperString()); }
	;
a_number returns [Fraction f] {Fraction f1,f2;}
	: f1=digit "and" f2=fraction { f=f1.add(f2); }
	| f=digit
	| f=fraction
	;
digit returns [Fraction f]
	: "one" { f=Fraction.valueOf(1); }
	| "two" { f=Fraction.valueOf(2); }
	| "three" { f=Fraction.valueOf(3); }
	| "four" { f=Fraction.valueOf(4); }
	| "five" { f=Fraction.valueOf(5); }
	| "six" { f=Fraction.valueOf(6); }
	| "seven" { f=Fraction.valueOf(7); }
	| "eight" { f=Fraction.valueOf(8); }
	| "nine" { f=Fraction.valueOf(9); }
	;
fraction returns [Fraction f]
	: ("a"|"one") "half" { f=Fraction.valueOf("1/2"); }
	| ("a"|"one") "third" { f=Fraction.valueOf("1/3"); }
	| ("a"|"one") "quarter" { f=Fraction.valueOf("1/4"); }
	| "two" "thirds" { f=Fraction.valueOf("2/3"); }
	| "three" "quarters" { f=Fraction.valueOf("3/4"); }
	;
cardinal returns [Apply a] {Fraction f=null;}
	: f=a_cardinal { a=Apply.makeApply(f.toProperString()); }
	;
a_cardinal returns [Fraction f] { Fraction f2=null; }
	: "once" ("and" f2=fraction)? { f=Fraction.valueOf(1); if (f2!=null) f=f.add(f2); }
	| "twice" ("and" f2=fraction)? { f=Fraction.valueOf(2); if (f2!=null) f=f.add(f2); }
	| f=a_number ("times"|"time")
	;

class @CLASSNAME@Lexer extends Lexer;
options {
  charVocabulary = '\0'..'\177'; // ascii only
  testLiterals=true;
  caseSensitiveLiterals=false;
}

WS
	: ( ' ' | '\t' )
    { $setType(Token.SKIP); }
    ;
IDENT
  : ('_'|'a'..'z'|'A'..'Z') ('_'|'a'..'z'|'A'..'Z'|'0'..'9'|'-')*
  ;
